"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EmbeddedCheckout: () => (/* binding */ EmbeddedCheckout),\n/* harmony export */   EmbeddedCheckoutProvider: () => (/* binding */ EmbeddedCheckoutProvider),\n/* harmony export */   ExpressCheckoutElement: () => (/* binding */ ExpressCheckoutElement),\n/* harmony export */   FinancialAccountDisclosure: () => (/* binding */ FinancialAccountDisclosure),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IssuingDisclosure: () => (/* binding */ IssuingDisclosure),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   TaxIdElement: () => (/* binding */ TaxIdElement),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n    var cbDefined = !!cb;\n    var cbRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cb); // In many integrations the callback prop changes on each render.\n    // Using a ref saves us from calling element.on/.off every render.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        cbRef.current = cb;\n    }, [\n        cb\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!cbDefined || !element) {\n            return function() {};\n        }\n        var decoratedCb = function decoratedCb() {\n            if (cbRef.current) {\n                cbRef.current.apply(cbRef, arguments);\n            }\n        };\n        element.on(event, decoratedCb);\n        return function() {\n            element.off(event, decoratedCb);\n        };\n    }, [\n        cbDefined,\n        event,\n        element,\n        cbRef\n    ]);\n};\nvar usePrevious = function usePrevious(value) {\n    var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n};\nvar isUnknownObject = function isUnknownObject(raw) {\n    return raw !== null && _typeof(raw) === \"object\";\n};\nvar isPromise = function isPromise(raw) {\n    return isUnknownObject(raw) && typeof raw.then === \"function\";\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\nvar isStripe = function isStripe(raw) {\n    return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = function isEqual(left, right) {\n    if (!isUnknownObject(left) || !isUnknownObject(right)) {\n        return left === right;\n    }\n    var leftArray = Array.isArray(left);\n    var rightArray = Array.isArray(right);\n    if (leftArray !== rightArray) return false;\n    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n    // fallback to reference check.\n    if (!leftPlainObject && !leftArray) return left === right;\n    var leftKeys = Object.keys(left);\n    var rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) return false;\n    var keySet = {};\n    for(var i = 0; i < leftKeys.length; i += 1){\n        keySet[leftKeys[i]] = true;\n    }\n    for(var _i = 0; _i < rightKeys.length; _i += 1){\n        keySet[rightKeys[_i]] = true;\n    }\n    var allKeys = Object.keys(keySet);\n    if (allKeys.length !== leftKeys.length) {\n        return false;\n    }\n    var l = left;\n    var r = right;\n    var pred = function pred(key) {\n        return isEqual(l[key], r[key]);\n    };\n    return allKeys.every(pred);\n};\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n    if (!isUnknownObject(options)) {\n        return null;\n    }\n    return Object.keys(options).reduce(function(newOptions, key) {\n        var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n        if (immutableKeys.includes(key)) {\n            if (isUpdated) {\n                console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n            }\n            return newOptions;\n        }\n        if (!isUpdated) {\n            return newOptions;\n        }\n        return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n    }, null);\n};\nvar INVALID_STRIPE_ERROR$1 = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\"; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\nvar validateStripe = function validateStripe(maybeStripe) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$1;\n    if (maybeStripe === null || isStripe(maybeStripe)) {\n        return maybeStripe;\n    }\n    throw new Error(errorMsg);\n};\nvar parseStripeProp = function parseStripeProp(raw) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$1;\n    if (isPromise(raw)) {\n        return {\n            tag: \"async\",\n            stripePromise: Promise.resolve(raw).then(function(result) {\n                return validateStripe(result, errorMsg);\n            })\n        };\n    }\n    var stripe = validateStripe(raw, errorMsg);\n    if (stripe === null) {\n        return {\n            tag: \"empty\"\n        };\n    }\n    return {\n        tag: \"sync\",\n        stripe: stripe\n    };\n};\nvar registerWithStripeJs = function registerWithStripeJs(stripe) {\n    if (!stripe || !stripe._registerWrapper || !stripe.registerAppInfo) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"react-stripe-js\",\n        version: \"5.4.1\"\n    });\n    stripe.registerAppInfo({\n        name: \"react-stripe-js\",\n        version: \"5.4.1\",\n        url: \"https://stripe.com/docs/stripe-js/react\"\n    });\n};\nvar ElementsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://docs.stripe.com/sdks/stripejs-react?ui=elements#elements-provider\n */ var Elements = function Elements(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]); // For a sync stripe instance, initialize into context\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n        };\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        var safeSetContext = function safeSetContext(stripe) {\n            setContext(function(ctx) {\n                // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n                if (ctx.stripe) return ctx;\n                return {\n                    stripe: stripe,\n                    elements: stripe.elements(options)\n                };\n            });\n        }; // For an async stripePromise, store it in context once resolved\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted) {\n                    // Only update Elements context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    safeSetContext(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n            // Or, handle a sync stripe instance going from null -> populated\n            safeSetContext(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!ctx.elements) {\n            return;\n        }\n        var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n            \"clientSecret\",\n            \"fonts\"\n        ]);\n        if (updates) {\n            ctx.elements.update(updates);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.elements\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ElementsContext.Provider, {\n        value: ctx\n    }, children);\n};\nElements.propTypes = {\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    return parseElementsContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */ var useElements = function useElements() {\n    var _useElementsContextWi = useElementsContextWithUseCase(\"calls useElements()\"), elements = _useElementsContextWi.elements;\n    return elements;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */ var ElementsConsumer = function ElementsConsumer(_ref2) {\n    var children = _ref2.children;\n    var ctx = useElementsContextWithUseCase(\"mounts <ElementsConsumer>\"); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n    return children(ctx);\n};\nElementsConsumer.propTypes = {\n    children: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired\n};\nvar CheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutContext.displayName = \"CheckoutContext\";\n({\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.shape({\n        clientSecret: prop_types__WEBPACK_IMPORTED_MODULE_1__.oneOfType([\n            prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n            prop_types__WEBPACK_IMPORTED_MODULE_1__.instanceOf(Promise)\n        ]).isRequired,\n        elementsOptions: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    }).isRequired\n});\nvar useElementsOrCheckoutContextWithUseCase = function useElementsOrCheckoutContextWithUseCase(useCaseString) {\n    var checkout = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutContext);\n    var elements = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    if (checkout) {\n        if (elements) {\n            throw new Error(\"You cannot wrap the part of your app that \".concat(useCaseString, \" in both <CheckoutProvider> and <Elements> providers.\"));\n        } else {\n            return checkout;\n        }\n    } else {\n        return parseElementsContext(elements, useCaseString);\n    }\n};\nvar _excluded = [\n    \"mode\"\n];\nvar capitalized = function capitalized(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nvar createElementComponent = function createElementComponent(type, isServer) {\n    var displayName = \"\".concat(capitalized(type), \"Element\");\n    var ClientElement = function ClientElement(_ref) {\n        var id = _ref.id, className = _ref.className, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onReady = _ref.onReady, onChange = _ref.onChange, onEscape = _ref.onEscape, onClick = _ref.onClick, onLoadError = _ref.onLoadError, onLoaderStart = _ref.onLoaderStart, onNetworksChange = _ref.onNetworksChange, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, onShippingAddressChange = _ref.onShippingAddressChange, onShippingRateChange = _ref.onShippingRateChange, onSavedPaymentMethodRemove = _ref.onSavedPaymentMethodRemove, onSavedPaymentMethodUpdate = _ref.onSavedPaymentMethodUpdate;\n        var ctx = useElementsOrCheckoutContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var elements = \"elements\" in ctx ? ctx.elements : null;\n        var checkoutState = \"checkoutState\" in ctx ? ctx.checkoutState : null;\n        var checkoutSdk = (checkoutState === null || checkoutState === void 0 ? void 0 : checkoutState.type) === \"success\" || (checkoutState === null || checkoutState === void 0 ? void 0 : checkoutState.type) === \"loading\" ? checkoutState.sdk : null;\n        var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];\n        var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n        var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); // For every event where the merchant provides a callback, call element.on\n        // with that callback. If the merchant ever changes the callback, removes\n        // the old callback with element.off and then call element.on with the new one.\n        useAttachEvent(element, \"blur\", onBlur);\n        useAttachEvent(element, \"focus\", onFocus);\n        useAttachEvent(element, \"escape\", onEscape);\n        useAttachEvent(element, \"click\", onClick);\n        useAttachEvent(element, \"loaderror\", onLoadError);\n        useAttachEvent(element, \"loaderstart\", onLoaderStart);\n        useAttachEvent(element, \"networkschange\", onNetworksChange);\n        useAttachEvent(element, \"confirm\", onConfirm);\n        useAttachEvent(element, \"cancel\", onCancel);\n        useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n        useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n        useAttachEvent(element, \"savedpaymentmethodremove\", onSavedPaymentMethodRemove);\n        useAttachEvent(element, \"savedpaymentmethodupdate\", onSavedPaymentMethodUpdate);\n        useAttachEvent(element, \"change\", onChange);\n        var readyCallback;\n        if (onReady) {\n            if (type === \"expressCheckout\") {\n                // Passes through the event, which includes visible PM types\n                readyCallback = onReady;\n            } else {\n                // For other Elements, pass through the Element itself.\n                readyCallback = function readyCallback() {\n                    onReady(element);\n                };\n            }\n        }\n        useAttachEvent(element, \"ready\", readyCallback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            if (elementRef.current === null && domNode.current !== null && (elements || checkoutSdk)) {\n                var newElement = null;\n                if (checkoutSdk) {\n                    switch(type){\n                        case \"paymentForm\":\n                            newElement = checkoutSdk.createPaymentFormElement();\n                            break;\n                        case \"payment\":\n                            newElement = checkoutSdk.createPaymentElement(options);\n                            break;\n                        case \"address\":\n                            if (\"mode\" in options) {\n                                var mode = options.mode, restOptions = _objectWithoutProperties(options, _excluded);\n                                if (mode === \"shipping\") {\n                                    newElement = checkoutSdk.createShippingAddressElement(restOptions);\n                                } else if (mode === \"billing\") {\n                                    newElement = checkoutSdk.createBillingAddressElement(restOptions);\n                                } else {\n                                    throw new Error(\"Invalid options.mode. mode must be 'billing' or 'shipping'.\");\n                                }\n                            } else {\n                                throw new Error(\"You must supply options.mode. mode must be 'billing' or 'shipping'.\");\n                            }\n                            break;\n                        case \"expressCheckout\":\n                            newElement = checkoutSdk.createExpressCheckoutElement(options);\n                            break;\n                        case \"currencySelector\":\n                            newElement = checkoutSdk.createCurrencySelectorElement();\n                            break;\n                        case \"taxId\":\n                            newElement = checkoutSdk.createTaxIdElement(options);\n                            break;\n                        default:\n                            throw new Error(\"Invalid Element type \".concat(displayName, \". You must use either the <PaymentElement />, <AddressElement options={{mode: 'shipping'}} />, <AddressElement options={{mode: 'billing'}} />, or <ExpressCheckoutElement />.\"));\n                    }\n                } else if (elements) {\n                    newElement = elements.create(type, options);\n                } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n                elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n                setElement(newElement);\n                if (newElement) {\n                    newElement.mount(domNode.current);\n                }\n            }\n        }, [\n            elements,\n            checkoutSdk,\n            options\n        ]);\n        var prevOptions = usePrevious(options);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n            if (!elementRef.current) {\n                return;\n            }\n            var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n                \"paymentRequest\"\n            ]);\n            if (updates && \"update\" in elementRef.current) {\n                elementRef.current.update(updates);\n            }\n        }, [\n            options,\n            prevOptions\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            return function() {\n                if (elementRef.current && typeof elementRef.current.destroy === \"function\") {\n                    try {\n                        elementRef.current.destroy();\n                        elementRef.current = null;\n                    } catch (error) {}\n                }\n            };\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className,\n            ref: domNode\n        });\n    }; // Only render the Element wrapper in a server environment.\n    var ServerElement = function ServerElement(props) {\n        useElementsOrCheckoutContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var id = props.id, className = props.className;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className\n        });\n    };\n    var Element = isServer ? ServerElement : ClientElement;\n    Element.propTypes = {\n        id: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        className: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        onChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onBlur: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onFocus: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onReady: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onEscape: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onClick: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoaderStart: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onNetworksChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onConfirm: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onCancel: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingAddressChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingRateChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onSavedPaymentMethodRemove: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onSavedPaymentMethodUpdate: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    };\n    Element.displayName = displayName;\n    Element.__elementType = type;\n    return Element;\n};\nvar isServer = \"undefined\" === \"undefined\";\nvar EmbeddedCheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nEmbeddedCheckoutContext.displayName = \"EmbeddedCheckoutProviderContext\";\nvar useEmbeddedCheckoutContext = function useEmbeddedCheckoutContext() {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EmbeddedCheckoutContext);\n    if (!ctx) {\n        throw new Error(\"<EmbeddedCheckout> must be used within <EmbeddedCheckoutProvider>\");\n    }\n    return ctx;\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `EmbeddedCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar EmbeddedCheckoutProvider = function EmbeddedCheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR);\n    }, [\n        rawStripeProp\n    ]);\n    var embeddedCheckoutPromise = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var loadedStripe = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        embeddedCheckout: null\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // Don't support any ctx updates once embeddedCheckout or stripe is set.\n        if (loadedStripe.current || embeddedCheckoutPromise.current) {\n            return;\n        }\n        var setStripeAndInitEmbeddedCheckout = function setStripeAndInitEmbeddedCheckout(stripe) {\n            if (loadedStripe.current || embeddedCheckoutPromise.current) return;\n            loadedStripe.current = stripe;\n            embeddedCheckoutPromise.current = loadedStripe.current.initEmbeddedCheckout(options).then(function(embeddedCheckout) {\n                setContext({\n                    embeddedCheckout: embeddedCheckout\n                });\n            });\n        }; // For an async stripePromise, store it once resolved\n        if (parsed.tag === \"async\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe) {\n                    setStripeAndInitEmbeddedCheckout(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            // Or, handle a sync stripe instance going from null -> populated\n            setStripeAndInitEmbeddedCheckout(parsed.stripe);\n        }\n    }, [\n        parsed,\n        options,\n        ctx,\n        loadedStripe\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // cleanup on unmount\n        return function() {\n            // If embedded checkout is fully initialized, destroy it.\n            if (ctx.embeddedCheckout) {\n                embeddedCheckoutPromise.current = null;\n                ctx.embeddedCheckout.destroy();\n            } else if (embeddedCheckoutPromise.current) {\n                // If embedded checkout is still initializing, destroy it once\n                // it's done. This could be caused by unmounting very quickly\n                // after mounting.\n                embeddedCheckoutPromise.current.then(function() {\n                    embeddedCheckoutPromise.current = null;\n                    if (ctx.embeddedCheckout) {\n                        ctx.embeddedCheckout.destroy();\n                    }\n                });\n            }\n        };\n    }, [\n        ctx.embeddedCheckout\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(loadedStripe);\n    }, [\n        loadedStripe\n    ]); // Warn on changes to stripe prop.\n    // The stripe prop value can only go from null to non-null once and\n    // can't be changed after that.\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Warn on changes to options.\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevOptions == null) {\n            return;\n        }\n        if (options == null) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot unset options after setting them.\");\n            return;\n        }\n        if (options.clientSecret === undefined && options.fetchClientSecret === undefined) {\n            console.warn(\"Invalid props passed to EmbeddedCheckoutProvider: You must provide one of either `options.fetchClientSecret` or `options.clientSecret`.\");\n        }\n        if (prevOptions.clientSecret != null && options.clientSecret !== prevOptions.clientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the client secret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.fetchClientSecret != null && options.fetchClientSecret !== prevOptions.fetchClientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change fetchClientSecret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.onComplete != null && options.onComplete !== prevOptions.onComplete) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onComplete option after setting it.\");\n        }\n        if (prevOptions.onShippingDetailsChange != null && options.onShippingDetailsChange !== prevOptions.onShippingDetailsChange) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onShippingDetailsChange option after setting it.\");\n        }\n        if (prevOptions.onLineItemsChange != null && options.onLineItemsChange !== prevOptions.onLineItemsChange) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onLineItemsChange option after setting it.\");\n        }\n    }, [\n        prevOptions,\n        options\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmbeddedCheckoutContext.Provider, {\n        value: ctx\n    }, children);\n};\nvar EmbeddedCheckoutClientElement = function EmbeddedCheckoutClientElement(_ref) {\n    var id = _ref.id, className = _ref.className;\n    var _useEmbeddedCheckoutC = useEmbeddedCheckoutContext(), embeddedCheckout = _useEmbeddedCheckoutC.embeddedCheckout;\n    var isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        if (!isMounted.current && embeddedCheckout && domNode.current !== null) {\n            embeddedCheckout.mount(domNode.current);\n            isMounted.current = true;\n        } // Clean up on unmount\n        return function() {\n            if (isMounted.current && embeddedCheckout) {\n                try {\n                    embeddedCheckout.unmount();\n                    isMounted.current = false;\n                } catch (e) {\n                // Parent effects are destroyed before child effects, so\n                // in cases where both the EmbeddedCheckoutProvider and\n                // the EmbeddedCheckout component are removed at the same\n                // time, the embeddedCheckout instance will be destroyed,\n                // which causes an error when calling unmount.\n                }\n            }\n        };\n    }, [\n        embeddedCheckout\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: domNode,\n        id: id,\n        className: className\n    });\n}; // Only render the wrapper in a server environment.\nvar EmbeddedCheckoutServerElement = function EmbeddedCheckoutServerElement(_ref2) {\n    var id = _ref2.id, className = _ref2.className;\n    // Validate that we are in the right context by calling useEmbeddedCheckoutContext.\n    useEmbeddedCheckoutContext();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: id,\n        className: className\n    });\n};\nvar EmbeddedCheckout = isServer ? EmbeddedCheckoutServerElement : EmbeddedCheckoutClientElement;\nvar FinancialAccountDisclosure = function FinancialAccountDisclosure(_ref) {\n    var rawStripeProp = _ref.stripe, onLoad = _ref.onLoad, onError = _ref.onError, options = _ref.options;\n    var businessName = options === null || options === void 0 ? void 0 : options.businessName;\n    var learnMoreLink = options === null || options === void 0 ? void 0 : options.learnMoreLink;\n    var containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(parsed.tag === \"sync\" ? parsed.stripe : null), _React$useState2 = _slicedToArray(_React$useState, 2), stripeState = _React$useState2[0], setStripeState = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        if (parsed.tag === \"async\") {\n            parsed.stripePromise.then(function(stripePromise) {\n                if (stripePromise && isMounted) {\n                    setStripeState(stripePromise);\n                }\n            });\n        } else if (parsed.tag === \"sync\") {\n            setStripeState(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on FinancialAccountDisclosure: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(stripeState);\n    }, [\n        stripeState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var createDisclosure = /*#__PURE__*/ function() {\n            var _ref2 = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n                var _yield$stripeState$cr, disclosureContent, error, container;\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while(1){\n                        switch(_context.prev = _context.next){\n                            case 0:\n                                if (!(!stripeState || !containerRef.current)) {\n                                    _context.next = 2;\n                                    break;\n                                }\n                                return _context.abrupt(\"return\");\n                            case 2:\n                                _context.next = 4;\n                                return stripeState.createFinancialAccountDisclosure({\n                                    businessName: businessName,\n                                    learnMoreLink: learnMoreLink\n                                });\n                            case 4:\n                                _yield$stripeState$cr = _context.sent;\n                                disclosureContent = _yield$stripeState$cr.htmlElement;\n                                error = _yield$stripeState$cr.error;\n                                if (error && onError) {\n                                    onError(error);\n                                } else if (disclosureContent) {\n                                    container = containerRef.current;\n                                    container.innerHTML = \"\";\n                                    container.appendChild(disclosureContent);\n                                    if (onLoad) {\n                                        onLoad();\n                                    }\n                                }\n                            case 8:\n                            case \"end\":\n                                return _context.stop();\n                        }\n                    }\n                }, _callee);\n            }));\n            return function createDisclosure() {\n                return _ref2.apply(this, arguments);\n            };\n        }();\n        createDisclosure();\n    }, [\n        stripeState,\n        businessName,\n        learnMoreLink,\n        onLoad,\n        onError\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: containerRef\n    });\n};\nvar IssuingDisclosure = function IssuingDisclosure(_ref) {\n    var rawStripeProp = _ref.stripe, onLoad = _ref.onLoad, onError = _ref.onError, options = _ref.options;\n    var issuingProgramID = options === null || options === void 0 ? void 0 : options.issuingProgramID;\n    var publicCardProgramName = options === null || options === void 0 ? void 0 : options.publicCardProgramName;\n    var learnMoreLink = options === null || options === void 0 ? void 0 : options.learnMoreLink;\n    var containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(parsed.tag === \"sync\" ? parsed.stripe : null), _React$useState2 = _slicedToArray(_React$useState, 2), stripeState = _React$useState2[0], setStripeState = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        if (parsed.tag === \"async\") {\n            parsed.stripePromise.then(function(stripePromise) {\n                if (stripePromise && isMounted) {\n                    setStripeState(stripePromise);\n                }\n            });\n        } else if (parsed.tag === \"sync\") {\n            setStripeState(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on IssuingDisclosure: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(stripeState);\n    }, [\n        stripeState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var createDisclosure = /*#__PURE__*/ function() {\n            var _ref2 = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n                var _yield$stripeState$cr, disclosureContent, error, container;\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while(1){\n                        switch(_context.prev = _context.next){\n                            case 0:\n                                if (!(!stripeState || !containerRef.current)) {\n                                    _context.next = 2;\n                                    break;\n                                }\n                                return _context.abrupt(\"return\");\n                            case 2:\n                                _context.next = 4;\n                                return stripeState.createIssuingDisclosure({\n                                    issuingProgramID: issuingProgramID,\n                                    publicCardProgramName: publicCardProgramName,\n                                    learnMoreLink: learnMoreLink\n                                });\n                            case 4:\n                                _yield$stripeState$cr = _context.sent;\n                                disclosureContent = _yield$stripeState$cr.htmlElement;\n                                error = _yield$stripeState$cr.error;\n                                if (error && onError) {\n                                    onError(error);\n                                } else if (disclosureContent) {\n                                    container = containerRef.current;\n                                    container.innerHTML = \"\";\n                                    container.appendChild(disclosureContent);\n                                    if (onLoad) {\n                                        onLoad();\n                                    }\n                                }\n                            case 8:\n                            case \"end\":\n                                return _context.stop();\n                        }\n                    }\n                }, _callee);\n            }));\n            return function createDisclosure() {\n                return _ref2.apply(this, arguments);\n            };\n        }();\n        createDisclosure();\n    }, [\n        stripeState,\n        issuingProgramID,\n        publicCardProgramName,\n        learnMoreLink,\n        onLoad,\n        onError\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: containerRef\n    });\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */ var useStripe = function useStripe() {\n    var _useElementsOrCheckou = useElementsOrCheckoutContextWithUseCase(\"calls useStripe()\"), stripe = _useElementsOrCheckou.stripe;\n    return stripe;\n};\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AuBankAccountElement = createElementComponent(\"auBankAccount\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardElement = createElementComponent(\"card\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardNumberElement = createElementComponent(\"cardNumber\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardExpiryElement = createElementComponent(\"cardExpiry\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardCvcElement = createElementComponent(\"cardCvc\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IbanElement = createElementComponent(\"iban\", isServer);\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ExpressCheckoutElement = createElementComponent(\"expressCheckout\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentRequestButtonElement = createElementComponent(\"paymentRequestButton\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var LinkAuthenticationElement = createElementComponent(\"linkAuthentication\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AddressElement = createElementComponent(\"address\", isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ShippingAddressElement = createElementComponent(\"shippingAddress\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentMethodMessagingElement = createElementComponent(\"paymentMethodMessaging\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n */ var TaxIdElement = createElementComponent(\"taxId\", isServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDUztBQUVuQyxTQUFTRSxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFDckMsSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRjtJQUV2QixJQUFJRyxPQUFPQyxxQkFBcUIsRUFBRTtRQUNoQyxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFFM0MsSUFBSUMsZ0JBQWdCO1lBQ2xCSSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztnQkFDcEMsT0FBT0osT0FBT0ssd0JBQXdCLENBQUNSLFFBQVFPLEtBQUtFLFVBQVU7WUFDaEU7UUFDRjtRQUVBUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFDeEI7SUFFQSxPQUFPSDtBQUNUO0FBRUEsU0FBU1UsZUFBZUMsTUFBTTtJQUM1QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1FBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRSxJQUFJLE9BQU9DLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHLENBQUM7UUFFcEQsSUFBSUEsSUFBSSxHQUFHO1lBQ1RmLFFBQVFJLE9BQU9jLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVVDLEdBQUc7Z0JBQ2pEQyxnQkFBZ0JQLFFBQVFNLEtBQUtGLE1BQU0sQ0FBQ0UsSUFBSTtZQUMxQztRQUNGLE9BQU8sSUFBSWhCLE9BQU9rQix5QkFBeUIsRUFBRTtZQUMzQ2xCLE9BQU9tQixnQkFBZ0IsQ0FBQ1QsUUFBUVYsT0FBT2tCLHlCQUF5QixDQUFDSjtRQUNuRSxPQUFPO1lBQ0xsQixRQUFRSSxPQUFPYyxTQUFTQyxPQUFPLENBQUMsU0FBVUMsR0FBRztnQkFDM0NoQixPQUFPb0IsY0FBYyxD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QUVBOztDQUVDLEdBRUQsSUFBSXlCLFlBQVksU0FBU0E7SUFDdkIsSUFBSUMsd0JBQXdCekcsd0NBQXdDLHNCQUNoRS9DLFNBQVN3SixzQkFBc0J4SixNQUFNO0lBRXpDLE9BQU9BO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUVELElBQUl5Six1QkFBdUJsRyx1QkFBdUIsaUJBQWlCRTtBQUNuRTs7Q0FFQyxHQUVELElBQUlpRyxjQUFjbkcsdUJBQXVCLFFBQVFFO0FBQ2pEOztDQUVDLEdBRUQsSUFBSWtHLG9CQUFvQnBHLHVCQUF1QixjQUFjRTtBQUM3RDs7Q0FFQyxHQUVELElBQUltRyxvQkFBb0JyRyx1QkFBdUIsY0FBY0U7QUFDN0Q7O0NBRUMsR0FFRCxJQUFJb0csaUJBQWlCdEcsdUJBQXVCLFdBQVdFO0FBQ3ZEOztDQUVDLEdBRUQsSUFBSXFHLGNBQWN2Ryx1QkFBdUIsUUFBUUU7QUFDakQsSUFBSXNHLGlCQUFpQnhHLHVCQUF1QixXQUFXRTtBQUN2RDs7Q0FFQyxHQUVELElBQUl1Ryx5QkFBeUJ6Ryx1QkFBdUIsbUJBQW1CRTtBQUN2RTs7Q0FFQyxHQUVELElBQUl3Ryw4QkFBOEIxRyx1QkFBdUIsd0JBQXdCRTtBQUNqRjs7Q0FFQyxHQUVELElBQUl5Ryw0QkFBNEIzRyx1QkFBdUIsc0JBQXNCRTtBQUM3RTs7Q0FFQyxHQUVELElBQUkwRyxpQkFBaUI1Ryx1QkFBdUIsV0FBV0U7QUFDdkQ7Ozs7O0NBS0MsR0FFRCxJQUFJMkcseUJBQXlCN0csdUJBQXVCLG1CQUFtQkU7QUFDdkU7O0NBRUMsR0FFRCxJQUFJNEcsZ0NBQWdDOUcsdUJBQXVCLDBCQUEwQkU7QUFDckY7OztDQUdDLEdBRUQsSUFBSTZHLGVBQWUvRyx1QkFBdUIsU0FBU0U7QUFFaVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb3ZlaWduLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2Rpc3QvcmVhY3Qtc3RyaXBlLmVzbS5tanM/YTE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyICYmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl0pO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciB1c2VBdHRhY2hFdmVudCA9IGZ1bmN0aW9uIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIGV2ZW50LCBjYikge1xuICB2YXIgY2JEZWZpbmVkID0gISFjYjtcbiAgdmFyIGNiUmVmID0gUmVhY3QudXNlUmVmKGNiKTsgLy8gSW4gbWFueSBpbnRlZ3JhdGlvbnMgdGhlIGNhbGxiYWNrIHByb3AgY2hhbmdlcyBvbiBlYWNoIHJlbmRlci5cbiAgLy8gVXNpbmcgYSByZWYgc2F2ZXMgdXMgZnJvbSBjYWxsaW5nIGVsZW1lbnQub24vLm9mZiBldmVyeSByZW5kZXIuXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBjYlJlZi5jdXJyZW50ID0gY2I7XG4gIH0sIFtjYl0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2JEZWZpbmVkIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgdmFyIGRlY29yYXRlZENiID0gZnVuY3Rpb24gZGVjb3JhdGVkQ2IoKSB7XG4gICAgICBpZiAoY2JSZWYuY3VycmVudCkge1xuICAgICAgICBjYlJlZi5jdXJyZW50LmFwcGx5KGNiUmVmLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVtZW50Lm9uKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQub2ZmKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgfTtcbiAgfSwgW2NiRGVmaW5lZCwgZXZlbnQsIGVsZW1lbnQsIGNiUmVmXSk7XG59O1xuXG52YXIgdXNlUHJldmlvdXMgPSBmdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufTtcblxudmFyIGlzVW5rbm93bk9iamVjdCA9IGZ1bmN0aW9uIGlzVW5rbm93bk9iamVjdChyYXcpIHtcbiAgcmV0dXJuIHJhdyAhPT0gbnVsbCAmJiBfdHlwZW9mKHJhdykgPT09ICdvYmplY3QnO1xufTtcbnZhciBpc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UocmF3KSB7XG4gIHJldHVybiBpc1Vua25vd25PYmplY3QocmF3KSAmJiB0eXBlb2YgcmF3LnRoZW4gPT09ICdmdW5jdGlvbic7XG59OyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYixcbi8vIGJ1dCBpbiBhbiB1bnR5cGVkIGludGVncmF0aW9uIGBzdHJpcGVgIGNvdWxkIGJlIGFueXRoaW5nLCBzbyB3ZSBuZWVkXG4vLyB0byBkbyBzb21lIHNhbml0eSB2YWxpZGF0aW9uIHRvIHByZXZlbnQgdHlwZSBlcnJvcnMuXG5cbnZhciBpc1N0cmlwZSA9IGZ1bmN0aW9uIGlzU3RyaXBlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy5lbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVRva2VuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByYXcuY3JlYXRlUGF5bWVudE1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNvbmZpcm1DYXJkUGF5bWVudCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBQTEFJTl9PQkpFQ1RfU1RSID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgaWYgKCFpc1Vua25vd25PYmplY3QobGVmdCkgfHwgIWlzVW5rbm93bk9iamVjdChyaWdodCkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH1cblxuICB2YXIgbGVmdEFycmF5ID0gQXJyYXkuaXNBcnJheShsZWZ0KTtcbiAgdmFyIHJpZ2h0QXJyYXkgPSBBcnJheS5pc0FycmF5KHJpZ2h0KTtcbiAgaWYgKGxlZnRBcnJheSAhPT0gcmlnaHRBcnJheSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbGVmdFBsYWluT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGxlZnQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICB2YXIgcmlnaHRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyaWdodCkgPT09IFBMQUlOX09CSkVDVF9TVFI7XG4gIGlmIChsZWZ0UGxhaW5PYmplY3QgIT09IHJpZ2h0UGxhaW5PYmplY3QpIHJldHVybiBmYWxzZTsgLy8gbm90IHN1cmUgd2hhdCBzb3J0IG9mIHNwZWNpYWwgb2JqZWN0IHRoaXMgaXMgKHJlZ2V4cCBpcyBvbmUgb3B0aW9uKSwgc29cbiAgLy8gZmFsbGJhY2sgdG8gcmVmZXJlbmNlIGNoZWNrLlxuXG4gIGlmICghbGVmdFBsYWluT2JqZWN0ICYmICFsZWZ0QXJyYXkpIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgdmFyIGxlZnRLZXlzID0gT2JqZWN0LmtleXMobGVmdCk7XG4gIHZhciByaWdodEtleXMgPSBPYmplY3Qua2V5cyhyaWdodCk7XG4gIGlmIChsZWZ0S2V5cy5sZW5ndGggIT09IHJpZ2h0S2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtleVNldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBrZXlTZXRbbGVmdEtleXNbaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCByaWdodEtleXMubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAga2V5U2V0W3JpZ2h0S2V5c1tfaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gT2JqZWN0LmtleXMoa2V5U2V0KTtcblxuICBpZiAoYWxsS2V5cy5sZW5ndGggIT09IGxlZnRLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsID0gbGVmdDtcbiAgdmFyIHIgPSByaWdodDtcblxuICB2YXIgcHJlZCA9IGZ1bmN0aW9uIHByZWQoa2V5KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobFtrZXldLCByW2tleV0pO1xuICB9O1xuXG4gIHJldHVybiBhbGxLZXlzLmV2ZXJ5KHByZWQpO1xufTtcblxudmFyIGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMgPSBmdW5jdGlvbiBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBpbW11dGFibGVLZXlzKSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKGZ1bmN0aW9uIChuZXdPcHRpb25zLCBrZXkpIHtcbiAgICB2YXIgaXNVcGRhdGVkID0gIWlzVW5rbm93bk9iamVjdChwcmV2T3B0aW9ucykgfHwgIWlzRXF1YWwob3B0aW9uc1trZXldLCBwcmV2T3B0aW9uc1trZXldKTtcblxuICAgIGlmIChpbW11dGFibGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlmIChpc1VwZGF0ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2U6IG9wdGlvbnMuXCIuY29uY2F0KGtleSwgXCIgaXMgbm90IGEgbXV0YWJsZSBwcm9wZXJ0eS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoIWlzVXBkYXRlZCkge1xuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBuZXdPcHRpb25zIHx8IHt9KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBvcHRpb25zW2tleV0pKTtcbiAgfSwgbnVsbCk7XG59O1xuXG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IkMSA9ICdJbnZhbGlkIHByb3AgYHN0cmlwZWAgc3VwcGxpZWQgdG8gYEVsZW1lbnRzYC4gV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgbG9hZFN0cmlwZWAgdXRpbGl0eSBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2AuIFNlZSBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtcHJvcHMtc3RyaXBlIGZvciBkZXRhaWxzLic7IC8vIFdlIGFyZSB1c2luZyB0eXBlcyB0byBlbmZvcmNlIHRoZSBgc3RyaXBlYCBwcm9wIGluIHRoaXMgbGliLCBidXQgaW4gYSByZWFsXG4vLyBpbnRlZ3JhdGlvbiBgc3RyaXBlYCBjb3VsZCBiZSBhbnl0aGluZywgc28gd2UgbmVlZCB0byBkbyBzb21lIHNhbml0eVxuLy8gdmFsaWRhdGlvbiB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLlxuXG52YXIgdmFsaWRhdGVTdHJpcGUgPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmlwZShtYXliZVN0cmlwZSkge1xuICB2YXIgZXJyb3JNc2cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IElOVkFMSURfU1RSSVBFX0VSUk9SJDE7XG5cbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsIHx8IGlzU3RyaXBlKG1heWJlU3RyaXBlKSkge1xuICAgIHJldHVybiBtYXliZVN0cmlwZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG59O1xuXG52YXIgcGFyc2VTdHJpcGVQcm9wID0gZnVuY3Rpb24gcGFyc2VTdHJpcGVQcm9wKHJhdykge1xuICB2YXIgZXJyb3JNc2cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IElOVkFMSURfU1RSSVBFX0VSUk9SJDE7XG5cbiAgaWYgKGlzUHJvbWlzZShyYXcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogJ2FzeW5jJyxcbiAgICAgIHN0cmlwZVByb21pc2U6IFByb21pc2UucmVzb2x2ZShyYXcpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHJpcGUocmVzdWx0LCBlcnJvck1zZyk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICB2YXIgc3RyaXBlID0gdmFsaWRhdGVTdHJpcGUocmF3LCBlcnJvck1zZyk7XG5cbiAgaWYgKHN0cmlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdlbXB0eSdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWc6ICdzeW5jJyxcbiAgICBzdHJpcGU6IHN0cmlwZVxuICB9O1xufTtcblxudmFyIHJlZ2lzdGVyV2l0aFN0cmlwZUpzID0gZnVuY3Rpb24gcmVnaXN0ZXJXaXRoU3RyaXBlSnMoc3RyaXBlKSB7XG4gIGlmICghc3RyaXBlIHx8ICFzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlciB8fCAhc3RyaXBlLnJlZ2lzdGVyQXBwSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICBuYW1lOiAncmVhY3Qtc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjUuNC4xXCJcbiAgfSk7XG5cbiAgc3RyaXBlLnJlZ2lzdGVyQXBwSW5mbyh7XG4gICAgbmFtZTogJ3JlYWN0LXN0cmlwZS1qcycsXG4gICAgdmVyc2lvbjogXCI1LjQuMVwiLFxuICAgIHVybDogJ2h0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCdcbiAgfSk7XG59O1xuXG52YXIgRWxlbWVudHNDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5FbGVtZW50c0NvbnRleHQuZGlzcGxheU5hbWUgPSAnRWxlbWVudHNDb250ZXh0JztcbnZhciBwYXJzZUVsZW1lbnRzQ29udGV4dCA9IGZ1bmN0aW9uIHBhcnNlRWxlbWVudHNDb250ZXh0KGN0eCwgdXNlQ2FzZSkge1xuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIEVsZW1lbnRzIGNvbnRleHQ7IFlvdSBuZWVkIHRvIHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZSwgXCIgaW4gYW4gPEVsZW1lbnRzPiBwcm92aWRlci5cIikpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG4vKipcbiAqIFRoZSBgRWxlbWVudHNgIHByb3ZpZGVyIGFsbG93cyB5b3UgdG8gdXNlIFtFbGVtZW50IGNvbXBvbmVudHNdKGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHMpIGFuZCBhY2Nlc3MgdGhlIFtTdHJpcGUgb2JqZWN0XShodHRwczovL3N0cmlwZS5jb20vZG9jcy9qcy9pbml0aWFsaXppbmcpIGluIGFueSBuZXN0ZWQgY29tcG9uZW50LlxuICogUmVuZGVyIGFuIGBFbGVtZW50c2AgcHJvdmlkZXIgYXQgdGhlIHJvb3Qgb2YgeW91ciBSZWFjdCBhcHAgc28gdGhhdCBpdCBpcyBhdmFpbGFibGUgZXZlcnl3aGVyZSB5b3UgbmVlZCBpdC5cbiAqXG4gKiBUbyB1c2UgdGhlIGBFbGVtZW50c2AgcHJvdmlkZXIsIGNhbGwgYGxvYWRTdHJpcGVgIGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYCB3aXRoIHlvdXIgcHVibGlzaGFibGUga2V5LlxuICogVGhlIGBsb2FkU3RyaXBlYCBmdW5jdGlvbiB3aWxsIGFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIFN0cmlwZS5qcyBzY3JpcHQgYW5kIGluaXRpYWxpemUgYSBgU3RyaXBlYCBvYmplY3QuXG4gKiBQYXNzIHRoZSByZXR1cm5lZCBgUHJvbWlzZWAgdG8gYEVsZW1lbnRzYC5cbiAqXG4gKiBAZG9jcyBodHRwczovL2RvY3Muc3RyaXBlLmNvbS9zZGtzL3N0cmlwZWpzLXJlYWN0P3VpPWVsZW1lbnRzI2VsZW1lbnRzLXByb3ZpZGVyXG4gKi9cblxudmFyIEVsZW1lbnRzID0gZnVuY3Rpb24gRWxlbWVudHMoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCk7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7IC8vIEZvciBhIHN5bmMgc3RyaXBlIGluc3RhbmNlLCBpbml0aWFsaXplIGludG8gY29udGV4dFxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmlwZTogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZSA6IG51bGwsXG4gICAgICBlbGVtZW50czogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZS5lbGVtZW50cyhvcHRpb25zKSA6IG51bGxcbiAgICB9O1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHRydWU7XG5cbiAgICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUpIHtcbiAgICAgIHNldENvbnRleHQoZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAvLyBuby1vcCBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdHJpcGUgaW5zdGFuY2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9zdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2lzc3Vlcy8yOTYpXG4gICAgICAgIGlmIChjdHguc3RyaXBlKSByZXR1cm4gY3R4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmlwZTogc3RyaXBlLFxuICAgICAgICAgIGVsZW1lbnRzOiBzdHJpcGUuZWxlbWVudHMob3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07IC8vIEZvciBhbiBhc3luYyBzdHJpcGVQcm9taXNlLCBzdG9yZSBpdCBpbiBjb250ZXh0IG9uY2UgcmVzb2x2ZWRcblxuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIEVsZW1lbnRzIGNvbnRleHQgaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkXG4gICAgICAgICAgLy8gYW5kIHN0cmlwZSBpcyBub3QgbnVsbC4gV2UgYWxsb3cgc3RyaXBlIHRvIGJlIG51bGwgdG8gbWFrZVxuICAgICAgICAgIC8vIGhhbmRsaW5nIFNTUiBlYXNpZXIuXG4gICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzYWZlU2V0Q29udGV4dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcFxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbGVtZW50czogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGBzdHJpcGVgIHByb3AgYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2U3RyaXBlLCByYXdTdHJpcGVQcm9wXSk7IC8vIEFwcGx5IHVwZGF0ZXMgdG8gZWxlbWVudHMgd2hlbiBvcHRpb25zIHByb3AgaGFzIHJlbGV2YW50IGNoYW5nZXNcblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWN0eC5lbGVtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydjbGllbnRTZWNyZXQnLCAnZm9udHMnXSk7XG5cbiAgICBpZiAodXBkYXRlcykge1xuICAgICAgY3R4LmVsZW1lbnRzLnVwZGF0ZSh1cGRhdGVzKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmVsZW1lbnRzXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGN0eC5zdHJpcGUpO1xuICB9LCBbY3R4LnN0cmlwZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCBjaGlsZHJlbik7XG59O1xuRWxlbWVudHMucHJvcFR5cGVzID0ge1xuICBzdHJpcGU6IFByb3BUeXBlcy5hbnksXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3Rcbn07XG52YXIgdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlTWVzc2FnZSkge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChFbGVtZW50c0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlZWxlbWVudHMtaG9va1xuICovXG5cbnZhciB1c2VFbGVtZW50cyA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzQ29udGV4dFdpID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUVsZW1lbnRzKCknKSxcbiAgICAgIGVsZW1lbnRzID0gX3VzZUVsZW1lbnRzQ29udGV4dFdpLmVsZW1lbnRzO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1jb25zdW1lclxuICovXG5cbnZhciBFbGVtZW50c0NvbnN1bWVyID0gZnVuY3Rpb24gRWxlbWVudHNDb25zdW1lcihfcmVmMikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbjtcbiAgdmFyIGN0eCA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdtb3VudHMgPEVsZW1lbnRzQ29uc3VtZXI+Jyk7IC8vIEFzc2VydCB0byBzYXRpc2Z5IHRoZSBidXN0ZWQgUmVhY3QuRkMgcmV0dXJuIHR5cGUgKGl0IHNob3VsZCBiZSBSZWFjdE5vZGUpXG5cbiAgcmV0dXJuIGNoaWxkcmVuKGN0eCk7XG59O1xuRWxlbWVudHNDb25zdW1lci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xuXG52YXIgQ2hlY2tvdXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5DaGVja291dENvbnRleHQuZGlzcGxheU5hbWUgPSAnQ2hlY2tvdXRDb250ZXh0Jztcbih7XG4gIHN0cmlwZTogUHJvcFR5cGVzLmFueSxcbiAgb3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjbGllbnRTZWNyZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5pbnN0YW5jZU9mKFByb21pc2UpXSkuaXNSZXF1aXJlZCxcbiAgICBlbGVtZW50c09wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufSk7XG52YXIgdXNlRWxlbWVudHNPckNoZWNrb3V0Q29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlRWxlbWVudHNPckNoZWNrb3V0Q29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VTdHJpbmcpIHtcbiAgdmFyIGNoZWNrb3V0ID0gUmVhY3QudXNlQ29udGV4dChDaGVja291dENvbnRleHQpO1xuICB2YXIgZWxlbWVudHMgPSBSZWFjdC51c2VDb250ZXh0KEVsZW1lbnRzQ29udGV4dCk7XG5cbiAgaWYgKGNoZWNrb3V0KSB7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZVN0cmluZywgXCIgaW4gYm90aCA8Q2hlY2tvdXRQcm92aWRlcj4gYW5kIDxFbGVtZW50cz4gcHJvdmlkZXJzLlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGVja291dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlRWxlbWVudHNDb250ZXh0KGVsZW1lbnRzLCB1c2VDYXNlU3RyaW5nKTtcbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCA9IFtcIm1vZGVcIl07XG5cbnZhciBjYXBpdGFsaXplZCA9IGZ1bmN0aW9uIGNhcGl0YWxpemVkKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxudmFyIGNyZWF0ZUVsZW1lbnRDb21wb25lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50Q29tcG9uZW50KHR5cGUsIGlzU2VydmVyKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemVkKHR5cGUpLCBcIkVsZW1lbnRcIik7XG5cbiAgdmFyIENsaWVudEVsZW1lbnQgPSBmdW5jdGlvbiBDbGllbnRFbGVtZW50KF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgb25CbHVyID0gX3JlZi5vbkJsdXIsXG4gICAgICAgIG9uRm9jdXMgPSBfcmVmLm9uRm9jdXMsXG4gICAgICAgIG9uUmVhZHkgPSBfcmVmLm9uUmVhZHksXG4gICAgICAgIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZSxcbiAgICAgICAgb25Fc2NhcGUgPSBfcmVmLm9uRXNjYXBlLFxuICAgICAgICBvbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgICAgICBvbkxvYWRFcnJvciA9IF9yZWYub25Mb2FkRXJyb3IsXG4gICAgICAgIG9uTG9hZGVyU3RhcnQgPSBfcmVmLm9uTG9hZGVyU3RhcnQsXG4gICAgICAgIG9uTmV0d29ya3NDaGFuZ2UgPSBfcmVmLm9uTmV0d29ya3NDaGFuZ2UsXG4gICAgICAgIG9uQ29uZmlybSA9IF9yZWYub25Db25maXJtLFxuICAgICAgICBvbkNhbmNlbCA9IF9yZWYub25DYW5jZWwsXG4gICAgICAgIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlID0gX3JlZi5vblNoaXBwaW5nQWRkcmVzc0NoYW5nZSxcbiAgICAgICAgb25TaGlwcGluZ1JhdGVDaGFuZ2UgPSBfcmVmLm9uU2hpcHBpbmdSYXRlQ2hhbmdlLFxuICAgICAgICBvblNhdmVkUGF5bWVudE1ldGhvZFJlbW92ZSA9IF9yZWYub25TYXZlZFBheW1lbnRNZXRob2RSZW1vdmUsXG4gICAgICAgIG9uU2F2ZWRQYXltZW50TWV0aG9kVXBkYXRlID0gX3JlZi5vblNhdmVkUGF5bWVudE1ldGhvZFVwZGF0ZTtcbiAgICB2YXIgY3R4ID0gdXNlRWxlbWVudHNPckNoZWNrb3V0Q29udGV4dFdpdGhVc2VDYXNlKFwibW91bnRzIDxcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiPlwiKSk7XG4gICAgdmFyIGVsZW1lbnRzID0gJ2VsZW1lbnRzJyBpbiBjdHggPyBjdHguZWxlbWVudHMgOiBudWxsO1xuICAgIHZhciBjaGVja291dFN0YXRlID0gJ2NoZWNrb3V0U3RhdGUnIGluIGN0eCA/IGN0eC5jaGVja291dFN0YXRlIDogbnVsbDtcbiAgICB2YXIgY2hlY2tvdXRTZGsgPSAoY2hlY2tvdXRTdGF0ZSA9PT0gbnVsbCB8fCBjaGVja291dFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGVja291dFN0YXRlLnR5cGUpID09PSAnc3VjY2VzcycgfHwgKGNoZWNrb3V0U3RhdGUgPT09IG51bGwgfHwgY2hlY2tvdXRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tvdXRTdGF0ZS50eXBlKSA9PT0gJ2xvYWRpbmcnID8gY2hlY2tvdXRTdGF0ZS5zZGsgOiBudWxsO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgICAgZWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICAgIHNldEVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gICAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIGRvbU5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIEZvciBldmVyeSBldmVudCB3aGVyZSB0aGUgbWVyY2hhbnQgcHJvdmlkZXMgYSBjYWxsYmFjaywgY2FsbCBlbGVtZW50Lm9uXG4gICAgLy8gd2l0aCB0aGF0IGNhbGxiYWNrLiBJZiB0aGUgbWVyY2hhbnQgZXZlciBjaGFuZ2VzIHRoZSBjYWxsYmFjaywgcmVtb3Zlc1xuICAgIC8vIHRoZSBvbGQgY2FsbGJhY2sgd2l0aCBlbGVtZW50Lm9mZiBhbmQgdGhlbiBjYWxsIGVsZW1lbnQub24gd2l0aCB0aGUgbmV3IG9uZS5cblxuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdibHVyJywgb25CbHVyKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZm9jdXMnLCBvbkZvY3VzKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZXNjYXBlJywgb25Fc2NhcGUpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJyb3InLCBvbkxvYWRFcnJvcik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2xvYWRlcnN0YXJ0Jywgb25Mb2FkZXJTdGFydCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ25ldHdvcmtzY2hhbmdlJywgb25OZXR3b3Jrc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NvbmZpcm0nLCBvbkNvbmZpcm0pO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NoaXBwaW5nYWRkcmVzc2NoYW5nZScsIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnc2hpcHBpbmdyYXRlY2hhbmdlJywgb25TaGlwcGluZ1JhdGVDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdzYXZlZHBheW1lbnRtZXRob2RyZW1vdmUnLCBvblNhdmVkUGF5bWVudE1ldGhvZFJlbW92ZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NhdmVkcGF5bWVudG1ldGhvZHVwZGF0ZScsIG9uU2F2ZWRQYXltZW50TWV0aG9kVXBkYXRlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIHZhciByZWFkeUNhbGxiYWNrO1xuXG4gICAgaWYgKG9uUmVhZHkpIHtcbiAgICAgIGlmICh0eXBlID09PSAnZXhwcmVzc0NoZWNrb3V0Jykge1xuICAgICAgICAvLyBQYXNzZXMgdGhyb3VnaCB0aGUgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIHZpc2libGUgUE0gdHlwZXNcbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IG9uUmVhZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb3RoZXIgRWxlbWVudHMsIHBhc3MgdGhyb3VnaCB0aGUgRWxlbWVudCBpdHNlbGYuXG4gICAgICAgIHJlYWR5Q2FsbGJhY2sgPSBmdW5jdGlvbiByZWFkeUNhbGxiYWNrKCkge1xuICAgICAgICAgIG9uUmVhZHkoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3JlYWR5JywgcmVhZHlDYWxsYmFjayk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQgPT09IG51bGwgJiYgZG9tTm9kZS5jdXJyZW50ICE9PSBudWxsICYmIChlbGVtZW50cyB8fCBjaGVja291dFNkaykpIHtcbiAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChjaGVja291dFNkaykge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncGF5bWVudEZvcm0nOlxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlUGF5bWVudEZvcm1FbGVtZW50KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdwYXltZW50JzpcbiAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGNoZWNrb3V0U2RrLmNyZWF0ZVBheW1lbnRFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgICAgICAgIGlmICgnbW9kZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdzaGlwcGluZycpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVTaGlwcGluZ0FkZHJlc3NFbGVtZW50KHJlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdiaWxsaW5nJykge1xuICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGNoZWNrb3V0U2RrLmNyZWF0ZUJpbGxpbmdBZGRyZXNzRWxlbWVudChyZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9ucy5tb2RlLiBtb2RlIG11c3QgYmUgJ2JpbGxpbmcnIG9yICdzaGlwcGluZycuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgb3B0aW9ucy5tb2RlLiBtb2RlIG11c3QgYmUgJ2JpbGxpbmcnIG9yICdzaGlwcGluZycuXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2V4cHJlc3NDaGVja291dCc6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVFeHByZXNzQ2hlY2tvdXRFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY3VycmVuY3lTZWxlY3Rvcic6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndGF4SWQnOlxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlVGF4SWRFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBFbGVtZW50IHR5cGUgXCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIi4gWW91IG11c3QgdXNlIGVpdGhlciB0aGUgPFBheW1lbnRFbGVtZW50IC8+LCA8QWRkcmVzc0VsZW1lbnQgb3B0aW9ucz17e21vZGU6ICdzaGlwcGluZyd9fSAvPiwgPEFkZHJlc3NFbGVtZW50IG9wdGlvbnM9e3ttb2RlOiAnYmlsbGluZyd9fSAvPiwgb3IgPEV4cHJlc3NDaGVja291dEVsZW1lbnQgLz4uXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICBuZXdFbGVtZW50ID0gZWxlbWVudHMuY3JlYXRlKHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9IC8vIFN0b3JlIGVsZW1lbnQgaW4gYSByZWYgdG8gZW5zdXJlIGl0J3MgX2ltbWVkaWF0ZWx5XyBhdmFpbGFibGUgaW4gY2xlYW51cCBob29rcyBpbiBTdHJpY3RNb2RlXG5cblxuICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBuZXdFbGVtZW50OyAvLyBTdG9yZSBlbGVtZW50IGluIHN0YXRlIHRvIGZhY2lsaXRhdGUgZXZlbnQgbGlzdGVuZXIgYXR0YWNobWVudFxuXG4gICAgICAgIHNldEVsZW1lbnQobmV3RWxlbWVudCk7XG5cbiAgICAgICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgICBuZXdFbGVtZW50Lm1vdW50KGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbZWxlbWVudHMsIGNoZWNrb3V0U2RrLCBvcHRpb25zXSk7XG4gICAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZXMgPSBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBbJ3BheW1lbnRSZXF1ZXN0J10pO1xuXG4gICAgICBpZiAodXBkYXRlcyAmJiAndXBkYXRlJyBpbiBlbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LnVwZGF0ZSh1cGRhdGVzKTtcbiAgICAgIH1cbiAgICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnNdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCAmJiB0eXBlb2YgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBEbyBub3RoaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICByZWY6IGRvbU5vZGVcbiAgICB9KTtcbiAgfTsgLy8gT25seSByZW5kZXIgdGhlIEVsZW1lbnQgd3JhcHBlciBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cblxuXG4gIHZhciBTZXJ2ZXJFbGVtZW50ID0gZnVuY3Rpb24gU2VydmVyRWxlbWVudChwcm9wcykge1xuICAgIHVzZUVsZW1lbnRzT3JDaGVja291dENvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpO1xuICAgIHZhciBpZCA9IHByb3BzLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEVsZW1lbnQgPSBpc1NlcnZlciA/IFNlcnZlckVsZW1lbnQgOiBDbGllbnRFbGVtZW50O1xuICBFbGVtZW50LnByb3BUeXBlcyA9IHtcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZWFkeTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Fc2NhcGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZEVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRlclN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbk5ldHdvcmtzQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNvbmZpcm06IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ1JhdGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2F2ZWRQYXltZW50TWV0aG9kUmVtb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNhdmVkUGF5bWVudE1ldGhvZFVwZGF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdFxuICB9O1xuICBFbGVtZW50LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIEVsZW1lbnQuX19lbGVtZW50VHlwZSA9IHR5cGU7XG4gIHJldHVybiBFbGVtZW50O1xufTtcblxudmFyIGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRW1iZWRkZWRDaGVja291dENvbnRleHQuZGlzcGxheU5hbWUgPSAnRW1iZWRkZWRDaGVja291dFByb3ZpZGVyQ29udGV4dCc7XG52YXIgdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQgPSBmdW5jdGlvbiB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRW1iZWRkZWRDaGVja291dENvbnRleHQpO1xuXG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8RW1iZWRkZWRDaGVja291dD4gbXVzdCBiZSB1c2VkIHdpdGhpbiA8RW1iZWRkZWRDaGVja291dFByb3ZpZGVyPicpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXJgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuJztcbnZhciBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgPSBmdW5jdGlvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCwgSU5WQUxJRF9TVFJJUEVfRVJST1IpO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pO1xuICB2YXIgZW1iZWRkZWRDaGVja291dFByb21pc2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBsb2FkZWRTdHJpcGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBlbWJlZGRlZENoZWNrb3V0OiBudWxsXG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBjdHggPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0Q29udGV4dCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEb24ndCBzdXBwb3J0IGFueSBjdHggdXBkYXRlcyBvbmNlIGVtYmVkZGVkQ2hlY2tvdXQgb3Igc3RyaXBlIGlzIHNldC5cbiAgICBpZiAobG9hZGVkU3RyaXBlLmN1cnJlbnQgfHwgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dCA9IGZ1bmN0aW9uIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHN0cmlwZSkge1xuICAgICAgaWYgKGxvYWRlZFN0cmlwZS5jdXJyZW50IHx8IGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGxvYWRlZFN0cmlwZS5jdXJyZW50ID0gc3RyaXBlO1xuICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCA9IGxvYWRlZFN0cmlwZS5jdXJyZW50LmluaXRFbWJlZGRlZENoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgc2V0Q29udGV4dCh7XG4gICAgICAgICAgZW1iZWRkZWRDaGVja291dDogZW1iZWRkZWRDaGVja291dFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07IC8vIEZvciBhbiBhc3luYyBzdHJpcGVQcm9taXNlLCBzdG9yZSBpdCBvbmNlIHJlc29sdmVkXG5cblxuICAgIGlmIChwYXJzZWQudGFnID09PSAnYXN5bmMnICYmICFsb2FkZWRTdHJpcGUuY3VycmVudCAmJiAob3B0aW9ucy5jbGllbnRTZWNyZXQgfHwgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCkpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlKSB7XG4gICAgICAgICAgc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQoc3RyaXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgIWxvYWRlZFN0cmlwZS5jdXJyZW50ICYmIChvcHRpb25zLmNsaWVudFNlY3JldCB8fCBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0KSkge1xuICAgICAgLy8gT3IsIGhhbmRsZSBhIHN5bmMgc3RyaXBlIGluc3RhbmNlIGdvaW5nIGZyb20gbnVsbCAtPiBwb3B1bGF0ZWRcbiAgICAgIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHBhcnNlZC5zdHJpcGUpO1xuICAgIH1cbiAgfSwgW3BhcnNlZCwgb3B0aW9ucywgY3R4LCBsb2FkZWRTdHJpcGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhbnVwIG9uIHVubW91bnRcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSWYgZW1iZWRkZWQgY2hlY2tvdXQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQsIGRlc3Ryb3kgaXQuXG4gICAgICBpZiAoY3R4LmVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN0eC5lbWJlZGRlZENoZWNrb3V0LmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSBpZiAoZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCkge1xuICAgICAgICAvLyBJZiBlbWJlZGRlZCBjaGVja291dCBpcyBzdGlsbCBpbml0aWFsaXppbmcsIGRlc3Ryb3kgaXQgb25jZVxuICAgICAgICAvLyBpdCdzIGRvbmUuIFRoaXMgY291bGQgYmUgY2F1c2VkIGJ5IHVubW91bnRpbmcgdmVyeSBxdWlja2x5XG4gICAgICAgIC8vIGFmdGVyIG1vdW50aW5nLlxuICAgICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGN0eC5lbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgICAgICBjdHguZW1iZWRkZWRDaGVja291dC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY3R4LmVtYmVkZGVkQ2hlY2tvdXRdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMobG9hZGVkU3RyaXBlKTtcbiAgfSwgW2xvYWRlZFN0cmlwZV0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gc3RyaXBlIHByb3AuXG4gIC8vIFRoZSBzdHJpcGUgcHJvcCB2YWx1ZSBjYW4gb25seSBnbyBmcm9tIG51bGwgdG8gbm9uLW51bGwgb25jZSBhbmRcbiAgLy8gY2FuJ3QgYmUgY2hhbmdlZCBhZnRlciB0aGF0LlxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gb3B0aW9ucy5cblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldk9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IHVuc2V0IG9wdGlvbnMgYWZ0ZXIgc2V0dGluZyB0aGVtLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNsaWVudFNlY3JldCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHByb3BzIHBhc3NlZCB0byBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBtdXN0IHByb3ZpZGUgb25lIG9mIGVpdGhlciBgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldGAgb3IgYG9wdGlvbnMuY2xpZW50U2VjcmV0YC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMuY2xpZW50U2VjcmV0ICE9IG51bGwgJiYgb3B0aW9ucy5jbGllbnRTZWNyZXQgIT09IHByZXZPcHRpb25zLmNsaWVudFNlY3JldCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBjbGllbnQgc2VjcmV0IGFmdGVyIHNldHRpbmcgaXQuIFVubW91bnQgYW5kIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQgIT0gbnVsbCAmJiBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ICE9PSBwcmV2T3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIGZldGNoQ2xpZW50U2VjcmV0IGFmdGVyIHNldHRpbmcgaXQuIFVubW91bnQgYW5kIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25Db21wbGV0ZSAhPSBudWxsICYmIG9wdGlvbnMub25Db21wbGV0ZSAhPT0gcHJldk9wdGlvbnMub25Db21wbGV0ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvbkNvbXBsZXRlIG9wdGlvbiBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3B0aW9ucy5vblNoaXBwaW5nRGV0YWlsc0NoYW5nZSAhPSBudWxsICYmIG9wdGlvbnMub25TaGlwcGluZ0RldGFpbHNDaGFuZ2UgIT09IHByZXZPcHRpb25zLm9uU2hpcHBpbmdEZXRhaWxzQ2hhbmdlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIG9uU2hpcHBpbmdEZXRhaWxzQ2hhbmdlIG9wdGlvbiBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3B0aW9ucy5vbkxpbmVJdGVtc0NoYW5nZSAhPSBudWxsICYmIG9wdGlvbnMub25MaW5lSXRlbXNDaGFuZ2UgIT09IHByZXZPcHRpb25zLm9uTGluZUl0ZW1zQ2hhbmdlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIG9uTGluZUl0ZW1zQ2hhbmdlIG9wdGlvbiBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZPcHRpb25zLCBvcHRpb25zXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbWJlZGRlZENoZWNrb3V0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHhcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxudmFyIEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50ID0gZnVuY3Rpb24gRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQoX3JlZikge1xuICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWU7XG5cbiAgdmFyIF91c2VFbWJlZGRlZENoZWNrb3V0QyA9IHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KCksXG4gICAgICBlbWJlZGRlZENoZWNrb3V0ID0gX3VzZUVtYmVkZGVkQ2hlY2tvdXRDLmVtYmVkZGVkQ2hlY2tvdXQ7XG5cbiAgdmFyIGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHZhciBkb21Ob2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNNb3VudGVkLmN1cnJlbnQgJiYgZW1iZWRkZWRDaGVja291dCAmJiBkb21Ob2RlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGVtYmVkZGVkQ2hlY2tvdXQubW91bnQoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9IC8vIENsZWFuIHVwIG9uIHVubW91bnRcblxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCAmJiBlbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZW1iZWRkZWRDaGVja291dC51bm1vdW50KCk7XG4gICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgLy8gUGFyZW50IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBiZWZvcmUgY2hpbGQgZWZmZWN0cywgc29cbiAgICAgICAgICAvLyBpbiBjYXNlcyB3aGVyZSBib3RoIHRoZSBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgYW5kXG4gICAgICAgICAgLy8gdGhlIEVtYmVkZGVkQ2hlY2tvdXQgY29tcG9uZW50IGFyZSByZW1vdmVkIGF0IHRoZSBzYW1lXG4gICAgICAgICAgLy8gdGltZSwgdGhlIGVtYmVkZGVkQ2hlY2tvdXQgaW5zdGFuY2Ugd2lsbCBiZSBkZXN0cm95ZWQsXG4gICAgICAgICAgLy8gd2hpY2ggY2F1c2VzIGFuIGVycm9yIHdoZW4gY2FsbGluZyB1bm1vdW50LlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VtYmVkZGVkQ2hlY2tvdXRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGRvbU5vZGUsXG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0pO1xufTsgLy8gT25seSByZW5kZXIgdGhlIHdyYXBwZXIgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cblxudmFyIEVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50ID0gZnVuY3Rpb24gRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQoX3JlZjIpIHtcbiAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWU7XG4gIC8vIFZhbGlkYXRlIHRoYXQgd2UgYXJlIGluIHRoZSByaWdodCBjb250ZXh0IGJ5IGNhbGxpbmcgdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQuXG4gIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0pO1xufTtcblxudmFyIEVtYmVkZGVkQ2hlY2tvdXQgPSBpc1NlcnZlciA/IEVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50IDogRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQ7XG5cbnZhciBGaW5hbmNpYWxBY2NvdW50RGlzY2xvc3VyZSA9IGZ1bmN0aW9uIEZpbmFuY2lhbEFjY291bnREaXNjbG9zdXJlKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9uTG9hZCA9IF9yZWYub25Mb2FkLFxuICAgICAgb25FcnJvciA9IF9yZWYub25FcnJvcixcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBidXNpbmVzc05hbWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYnVzaW5lc3NOYW1lO1xuICB2YXIgbGVhcm5Nb3JlTGluayA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sZWFybk1vcmVMaW5rO1xuICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgcGFyc2VkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlU3RyaXBlUHJvcChyYXdTdHJpcGVQcm9wKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUocGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZSA6IG51bGwpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBzdHJpcGVTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRTdHJpcGVTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIGlmIChwYXJzZWQudGFnID09PSAnYXN5bmMnKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGVQcm9taXNlKSB7XG4gICAgICAgIGlmIChzdHJpcGVQcm9taXNlICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIHNldFN0cmlwZVN0YXRlKHN0cmlwZVByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC50YWcgPT09ICdzeW5jJykge1xuICAgICAgc2V0U3RyaXBlU3RhdGUocGFyc2VkLnN0cmlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtwYXJzZWRdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wXG5cbiAgdmFyIHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldlN0cmlwZSAhPT0gbnVsbCAmJiBwcmV2U3RyaXBlICE9PSByYXdTdHJpcGVQcm9wKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEZpbmFuY2lhbEFjY291bnREaXNjbG9zdXJlOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMoc3RyaXBlU3RhdGUpO1xuICB9LCBbc3RyaXBlU3RhdGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3JlYXRlRGlzY2xvc3VyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfeWllbGQkc3RyaXBlU3RhdGUkY3IsIGRpc2Nsb3N1cmVDb250ZW50LCBlcnJvciwgY29udGFpbmVyO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoISghc3RyaXBlU3RhdGUgfHwgIWNvbnRhaW5lclJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXBlU3RhdGUuY3JlYXRlRmluYW5jaWFsQWNjb3VudERpc2Nsb3N1cmUoe1xuICAgICAgICAgICAgICAgICAgYnVzaW5lc3NOYW1lOiBidXNpbmVzc05hbWUsXG4gICAgICAgICAgICAgICAgICBsZWFybk1vcmVMaW5rOiBsZWFybk1vcmVMaW5rXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF95aWVsZCRzdHJpcGVTdGF0ZSRjciA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgZGlzY2xvc3VyZUNvbnRlbnQgPSBfeWllbGQkc3RyaXBlU3RhdGUkY3IuaHRtbEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQkc3RyaXBlU3RhdGUkY3IuZXJyb3I7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXNjbG9zdXJlQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGlzY2xvc3VyZUNvbnRlbnQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVEaXNjbG9zdXJlKCkge1xuICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgY3JlYXRlRGlzY2xvc3VyZSgpO1xuICB9LCBbc3RyaXBlU3RhdGUsIGJ1c2luZXNzTmFtZSwgbGVhcm5Nb3JlTGluaywgb25Mb2FkLCBvbkVycm9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgIHJlZjogY29udGFpbmVyUmVmXG4gIH0pO1xufTtcblxudmFyIElzc3VpbmdEaXNjbG9zdXJlID0gZnVuY3Rpb24gSXNzdWluZ0Rpc2Nsb3N1cmUoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb25Mb2FkID0gX3JlZi5vbkxvYWQsXG4gICAgICBvbkVycm9yID0gX3JlZi5vbkVycm9yLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGlzc3VpbmdQcm9ncmFtSUQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaXNzdWluZ1Byb2dyYW1JRDtcbiAgdmFyIHB1YmxpY0NhcmRQcm9ncmFtTmFtZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wdWJsaWNDYXJkUHJvZ3JhbU5hbWU7XG4gIHZhciBsZWFybk1vcmVMaW5rID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxlYXJuTW9yZUxpbms7XG4gIHZhciBjb250YWluZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3ApO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlIDogbnVsbCksXG4gICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgIHN0cmlwZVN0YXRlID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFN0cmlwZVN0YXRlID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZVByb21pc2UpIHtcbiAgICAgICAgaWYgKHN0cmlwZVByb21pc2UgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgc2V0U3RyaXBlU3RhdGUoc3RyaXBlUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnKSB7XG4gICAgICBzZXRTdHJpcGVTdGF0ZShwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZF0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gc3RyaXBlIHByb3BcblxuICB2YXIgcHJldlN0cmlwZSA9IHVzZVByZXZpb3VzKHJhd1N0cmlwZVByb3ApO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2U3RyaXBlICE9PSBudWxsICYmIHByZXZTdHJpcGUgIT09IHJhd1N0cmlwZVByb3ApIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gSXNzdWluZ0Rpc2Nsb3N1cmU6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBBdHRhY2ggcmVhY3Qtc3RyaXBlLWpzIHZlcnNpb24gdG8gc3RyaXBlLmpzIGluc3RhbmNlXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWdpc3RlcldpdGhTdHJpcGVKcyhzdHJpcGVTdGF0ZSk7XG4gIH0sIFtzdHJpcGVTdGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjcmVhdGVEaXNjbG9zdXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIF95aWVsZCRzdHJpcGVTdGF0ZSRjciwgZGlzY2xvc3VyZUNvbnRlbnQsIGVycm9yLCBjb250YWluZXI7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghKCFzdHJpcGVTdGF0ZSB8fCAhY29udGFpbmVyUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpcGVTdGF0ZS5jcmVhdGVJc3N1aW5nRGlzY2xvc3VyZSh7XG4gICAgICAgICAgICAgICAgICBpc3N1aW5nUHJvZ3JhbUlEOiBpc3N1aW5nUHJvZ3JhbUlELFxuICAgICAgICAgICAgICAgICAgcHVibGljQ2FyZFByb2dyYW1OYW1lOiBwdWJsaWNDYXJkUHJvZ3JhbU5hbWUsXG4gICAgICAgICAgICAgICAgICBsZWFybk1vcmVMaW5rOiBsZWFybk1vcmVMaW5rXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF95aWVsZCRzdHJpcGVTdGF0ZSRjciA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgZGlzY2xvc3VyZUNvbnRlbnQgPSBfeWllbGQkc3RyaXBlU3RhdGUkY3IuaHRtbEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQkc3RyaXBlU3RhdGUkY3IuZXJyb3I7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXNjbG9zdXJlQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGlzY2xvc3VyZUNvbnRlbnQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVEaXNjbG9zdXJlKCkge1xuICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgY3JlYXRlRGlzY2xvc3VyZSgpO1xuICB9LCBbc3RyaXBlU3RhdGUsIGlzc3VpbmdQcm9ncmFtSUQsIHB1YmxpY0NhcmRQcm9ncmFtTmFtZSwgbGVhcm5Nb3JlTGluaywgb25Mb2FkLCBvbkVycm9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgIHJlZjogY29udGFpbmVyUmVmXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlc3RyaXBlLWhvb2tcbiAqL1xuXG52YXIgdXNlU3RyaXBlID0gZnVuY3Rpb24gdXNlU3RyaXBlKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzT3JDaGVja291ID0gdXNlRWxlbWVudHNPckNoZWNrb3V0Q29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VTdHJpcGUoKScpLFxuICAgICAgc3RyaXBlID0gX3VzZUVsZW1lbnRzT3JDaGVja291LnN0cmlwZTtcblxuICByZXR1cm4gc3RyaXBlO1xufTtcblxuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQXVCYW5rQWNjb3VudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhdUJhbmtBY2NvdW50JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkTnVtYmVyRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmROdW1iZXInLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEV4cGlyeUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkRXhwaXJ5JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRDdmNFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZEN2YycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBJYmFuRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2liYW4nLCBpc1NlcnZlcik7XG52YXIgUGF5bWVudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwYXltZW50JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEV4cHJlc3NDaGVja291dEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdleHByZXNzQ2hlY2tvdXQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudFJlcXVlc3RCdXR0b24nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2xpbmtBdXRoZW50aWNhdGlvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2UgYEFkZHJlc3NFbGVtZW50YCBpbnN0ZWFkLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3NoaXBwaW5nQWRkcmVzcycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnRNZXRob2RNZXNzYWdpbmcnLCBpc1NlcnZlcik7XG4vKipcbiAqIFJlcXVpcmVzIGJldGEgYWNjZXNzOlxuICogQ29udGFjdCBbU3RyaXBlIHN1cHBvcnRdKGh0dHBzOi8vc3VwcG9ydC5zdHJpcGUuY29tLykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cblxudmFyIFRheElkRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3RheElkJywgaXNTZXJ2ZXIpO1xuXG5leHBvcnQgeyBBZGRyZXNzRWxlbWVudCwgQXVCYW5rQWNjb3VudEVsZW1lbnQsIENhcmRDdmNFbGVtZW50LCBDYXJkRWxlbWVudCwgQ2FyZEV4cGlyeUVsZW1lbnQsIENhcmROdW1iZXJFbGVtZW50LCBFbGVtZW50cywgRWxlbWVudHNDb25zdW1lciwgRW1iZWRkZWRDaGVja291dCwgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyLCBFeHByZXNzQ2hlY2tvdXRFbGVtZW50LCBGaW5hbmNpYWxBY2NvdW50RGlzY2xvc3VyZSwgSWJhbkVsZW1lbnQsIElzc3VpbmdEaXNjbG9zdXJlLCBMaW5rQXV0aGVudGljYXRpb25FbGVtZW50LCBQYXltZW50RWxlbWVudCwgUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQsIFBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCwgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCwgVGF4SWRFbGVtZW50LCB1c2VFbGVtZW50cywgdXNlU3RyaXBlIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJQcm9wVHlwZXMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93IiwiYXJnIiwiaW5mbyIsInZhbHVlIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwic2VsZiIsImFyZ3MiLCJlcnIiLCJ1bmRlZmluZWQiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwiaW5kZXhPZiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJBcnJheSIsImlzQXJyYXkiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIm5leHQiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJUeXBlRXJyb3IiLCJ1c2VBdHRhY2hFdmVudCIsImVsZW1lbnQiLCJldmVudCIsImNiIiwiY2JEZWZpbmVkIiwiY2JSZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiZGVjb3JhdGVkQ2IiLCJvbiIsIm9mZiIsInVzZVByZXZpb3VzIiwicmVmIiwiaXNVbmtub3duT2JqZWN0IiwicmF3IiwiaXNQcm9taXNlIiwiaXNTdHJpcGUiLCJlbGVtZW50cyIsImNyZWF0ZVRva2VuIiwiY3JlYXRlUGF5bWVudE1ldGhvZCIsImNvbmZpcm1DYXJkUGF5bWVudCIsIlBMQUlOX09CSkVDVF9TVFIiLCJpc0VxdWFsIiwibGVmdCIsInJpZ2h0IiwibGVmdEFycmF5IiwicmlnaHRBcnJheSIsImxlZnRQbGFpbk9iamVjdCIsInJpZ2h0UGxhaW5PYmplY3QiLCJsZWZ0S2V5cyIsInJpZ2h0S2V5cyIsImtleVNldCIsImFsbEtleXMiLCJsIiwiciIsInByZWQiLCJldmVyeSIsImV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMiLCJvcHRpb25zIiwicHJldk9wdGlvbnMiLCJpbW11dGFibGVLZXlzIiwicmVkdWNlIiwibmV3T3B0aW9ucyIsImlzVXBkYXRlZCIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJjb25jYXQiLCJJTlZBTElEX1NUUklQRV9FUlJPUiQxIiwidmFsaWRhdGVTdHJpcGUiLCJtYXliZVN0cmlwZSIsImVycm9yTXNnIiwiRXJyb3IiLCJwYXJzZVN0cmlwZVByb3AiLCJ0YWciLCJzdHJpcGVQcm9taXNlIiwicmVzdWx0Iiwic3RyaXBlIiwicmVnaXN0ZXJXaXRoU3RyaXBlSnMiLCJfcmVnaXN0ZXJXcmFwcGVyIiwicmVnaXN0ZXJBcHBJbmZvIiwidmVyc2lvbiIsInVybCIsIkVsZW1lbnRzQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsInBhcnNlRWxlbWVudHNDb250ZXh0IiwiY3R4IiwidXNlQ2FzZSIsIkVsZW1lbnRzIiwiX3JlZiIsInJhd1N0cmlwZVByb3AiLCJjaGlsZHJlbiIsInBhcnNlZCIsInVzZU1lbW8iLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJzZXRDb250ZXh0IiwiaXNNb3VudGVkIiwic2FmZVNldENvbnRleHQiLCJwcmV2U3RyaXBlIiwidXBkYXRlcyIsInVwZGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInByb3BUeXBlcyIsImFueSIsInVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlIiwidXNlQ2FzZU1lc3NhZ2UiLCJ1c2VDb250ZXh0IiwidXNlRWxlbWVudHMiLCJfdXNlRWxlbWVudHNDb250ZXh0V2kiLCJFbGVtZW50c0NvbnN1bWVyIiwiX3JlZjIiLCJmdW5jIiwiaXNSZXF1aXJlZCIsIkNoZWNrb3V0Q29udGV4dCIsInNoYXBlIiwiY2xpZW50U2VjcmV0Iiwib25lT2ZUeXBlIiwic3RyaW5nIiwiaW5zdGFuY2VPZiIsImVsZW1lbnRzT3B0aW9ucyIsInVzZUVsZW1lbnRzT3JDaGVja291dENvbnRleHRXaXRoVXNlQ2FzZSIsInVzZUNhc2VTdHJpbmciLCJjaGVja291dCIsIl9leGNsdWRlZCIsImNhcGl0YWxpemVkIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJjcmVhdGVFbGVtZW50Q29tcG9uZW50IiwidHlwZSIsImlzU2VydmVyIiwiQ2xpZW50RWxlbWVudCIsImlkIiwiY2xhc3NOYW1lIiwiX3JlZiRvcHRpb25zIiwib25CbHVyIiwib25Gb2N1cyIsIm9uUmVhZHkiLCJvbkNoYW5nZSIsIm9uRXNjYXBlIiwib25DbGljayIsIm9uTG9hZEVycm9yIiwib25Mb2FkZXJTdGFydCIsIm9uTmV0d29ya3NDaGFuZ2UiLCJvbkNvbmZpcm0iLCJvbkNhbmNlbCIsIm9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlIiwib25TaGlwcGluZ1JhdGVDaGFuZ2UiLCJvblNhdmVkUGF5bWVudE1ldGhvZFJlbW92ZSIsIm9uU2F2ZWRQYXltZW50TWV0aG9kVXBkYXRlIiwiY2hlY2tvdXRTdGF0ZSIsImNoZWNrb3V0U2RrIiwic2RrIiwic2V0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJkb21Ob2RlIiwicmVhZHlDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsIm5ld0VsZW1lbnQiLCJjcmVhdGVQYXltZW50Rm9ybUVsZW1lbnQiLCJjcmVhdGVQYXltZW50RWxlbWVudCIsIm1vZGUiLCJyZXN0T3B0aW9ucyIsImNyZWF0ZVNoaXBwaW5nQWRkcmVzc0VsZW1lbnQiLCJjcmVhdGVCaWxsaW5nQWRkcmVzc0VsZW1lbnQiLCJjcmVhdGVFeHByZXNzQ2hlY2tvdXRFbGVtZW50IiwiY3JlYXRlQ3VycmVuY3lTZWxlY3RvckVsZW1lbnQiLCJjcmVhdGVUYXhJZEVsZW1lbnQiLCJjcmVhdGUiLCJtb3VudCIsImRlc3Ryb3kiLCJTZXJ2ZXJFbGVtZW50IiwicHJvcHMiLCJFbGVtZW50IiwiX19lbGVtZW50VHlwZSIsIkVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0IiwidXNlRW1iZWRkZWRDaGVja291dENvbnRleHQiLCJJTlZBTElEX1NUUklQRV9FUlJPUiIsIkVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciIsImVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlIiwibG9hZGVkU3RyaXBlIiwiZW1iZWRkZWRDaGVja291dCIsInNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0IiwiaW5pdEVtYmVkZGVkQ2hlY2tvdXQiLCJmZXRjaENsaWVudFNlY3JldCIsIm9uQ29tcGxldGUiLCJvblNoaXBwaW5nRGV0YWlsc0NoYW5nZSIsIm9uTGluZUl0ZW1zQ2hhbmdlIiwiRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQiLCJfdXNlRW1iZWRkZWRDaGVja291dEMiLCJ1bm1vdW50IiwiZSIsIkVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50IiwiRW1iZWRkZWRDaGVja291dCIsIkZpbmFuY2lhbEFjY291bnREaXNjbG9zdXJlIiwib25Mb2FkIiwib25FcnJvciIsImJ1c2luZXNzTmFtZSIsImxlYXJuTW9yZUxpbmsiLCJjb250YWluZXJSZWYiLCJzdHJpcGVTdGF0ZSIsInNldFN0cmlwZVN0YXRlIiwiY3JlYXRlRGlzY2xvc3VyZSIsInJlZ2VuZXJhdG9yUnVudGltZSIsIm1hcmsiLCJfY2FsbGVlIiwiX3lpZWxkJHN0cmlwZVN0YXRlJGNyIiwiZGlzY2xvc3VyZUNvbnRlbnQiLCJjb250YWluZXIiLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInByZXYiLCJhYnJ1cHQiLCJjcmVhdGVGaW5hbmNpYWxBY2NvdW50RGlzY2xvc3VyZSIsInNlbnQiLCJodG1sRWxlbWVudCIsImlubmVySFRNTCIsImFwcGVuZENoaWxkIiwic3RvcCIsIklzc3VpbmdEaXNjbG9zdXJlIiwiaXNzdWluZ1Byb2dyYW1JRCIsInB1YmxpY0NhcmRQcm9ncmFtTmFtZSIsImNyZWF0ZUlzc3VpbmdEaXNjbG9zdXJlIiwidXNlU3RyaXBlIiwiX3VzZUVsZW1lbnRzT3JDaGVja291IiwiQXVCYW5rQWNjb3VudEVsZW1lbnQiLCJDYXJkRWxlbWVudCIsIkNhcmROdW1iZXJFbGVtZW50IiwiQ2FyZEV4cGlyeUVsZW1lbnQiLCJDYXJkQ3ZjRWxlbWVudCIsIkliYW5FbGVtZW50IiwiUGF5bWVudEVsZW1lbnQiLCJFeHByZXNzQ2hlY2tvdXRFbGVtZW50IiwiUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50IiwiTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCIsIkFkZHJlc3NFbGVtZW50IiwiU2hpcHBpbmdBZGRyZXNzRWxlbWVudCIsIlBheW1lbnRNZXRob2RNZXNzYWdpbmdFbGVtZW50IiwiVGF4SWRFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadStripe: () => (/* binding */ loadStripe)\n/* harmony export */ });\nvar RELEASE_TRAIN = \"clover\";\nvar runtimeVersionToUrlVersion = function runtimeVersionToUrlVersion(version) {\n    return version === 3 ? \"v3\" : version;\n};\nvar ORIGIN = \"https://js.stripe.com\";\nvar STRIPE_JS_URL = \"\".concat(ORIGIN, \"/\").concat(RELEASE_TRAIN, \"/stripe.js\");\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar STRIPE_JS_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/(v3|[a-z]+)\\/stripe\\.js(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = \"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used\";\nvar isStripeJSURL = function isStripeJSURL(url) {\n    return V3_URL_REGEX.test(url) || STRIPE_JS_URL_REGEX.test(url);\n};\nvar findScript = function findScript() {\n    var scripts = document.querySelectorAll('script[src^=\"'.concat(ORIGIN, '\"]'));\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (!isStripeJSURL(script.src)) {\n            continue;\n        }\n        return script;\n    }\n    return null;\n};\nvar injectScript = function injectScript(params) {\n    var queryString = params && !params.advancedFraudSignals ? \"?advancedFraudSignals=false\" : \"\";\n    var script = document.createElement(\"script\");\n    script.src = \"\".concat(STRIPE_JS_URL).concat(queryString);\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n        throw new Error(\"Expected document.body not to be null. Stripe.js requires a <body> element.\");\n    }\n    headOrBody.appendChild(script);\n    return script;\n};\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n    if (!stripe || !stripe._registerWrapper) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"stripe-js\",\n        version: \"8.5.3\",\n        startTime: startTime\n    });\n};\nvar stripePromise$1 = null;\nvar onErrorListener = null;\nvar onLoadListener = null;\nvar onError = function onError(reject) {\n    return function(cause) {\n        reject(new Error(\"Failed to load Stripe.js\", {\n            cause: cause\n        }));\n    };\n};\nvar onLoad = function onLoad(resolve, reject) {\n    return function() {\n        if (window.Stripe) {\n            resolve(window.Stripe);\n        } else {\n            reject(new Error(\"Stripe.js not available\"));\n        }\n    };\n};\nvar loadScript = function loadScript(params) {\n    // Ensure that we only attempt to load Stripe.js at most once\n    if (stripePromise$1 !== null) {\n        return stripePromise$1;\n    }\n    stripePromise$1 = new Promise(function(resolve, reject) {\n        if (true) {\n            // Resolve to null when imported server side. This makes the module\n            // safe to import in an isomorphic code base.\n            resolve(null);\n            return;\n        }\n        if (window.Stripe && params) {\n            console.warn(EXISTING_SCRIPT_MESSAGE);\n        }\n        if (window.Stripe) {\n            resolve(window.Stripe);\n            return;\n        }\n        try {\n            var script = findScript();\n            if (script && params) {\n                console.warn(EXISTING_SCRIPT_MESSAGE);\n            } else if (!script) {\n                script = injectScript(params);\n            } else if (script && onLoadListener !== null && onErrorListener !== null) {\n                var _script$parentNode;\n                // remove event listeners\n                script.removeEventListener(\"load\", onLoadListener);\n                script.removeEventListener(\"error\", onErrorListener); // if script exists, but we are reloading due to an error,\n                // reload script to trigger 'load' event\n                (_script$parentNode = script.parentNode) === null || _script$parentNode === void 0 ? void 0 : _script$parentNode.removeChild(script);\n                script = injectScript(params);\n            }\n            onLoadListener = onLoad(resolve, reject);\n            onErrorListener = onError(reject);\n            script.addEventListener(\"load\", onLoadListener);\n            script.addEventListener(\"error\", onErrorListener);\n        } catch (error) {\n            reject(error);\n            return;\n        }\n    }); // Resets stripePromise on error\n    return stripePromise$1[\"catch\"](function(error) {\n        stripePromise$1 = null;\n        return Promise.reject(error);\n    });\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n    if (maybeStripe === null) {\n        return null;\n    }\n    var pk = args[0];\n    var isTestKey = pk.match(/^pk_test/); // @ts-expect-error this is not publicly typed\n    var version = runtimeVersionToUrlVersion(maybeStripe.version);\n    var expectedVersion = RELEASE_TRAIN;\n    if (isTestKey && version !== expectedVersion) {\n        console.warn(\"Stripe.js@\".concat(version, \" was loaded on the page, but @stripe/stripe-js@\").concat(\"8.5.3\", \" expected Stripe.js@\").concat(expectedVersion, \". This may result in unexpected behavior. For more information, see https://docs.stripe.com/sdks/stripejs-versioning\"));\n    }\n    var stripe = maybeStripe.apply(undefined, args);\n    registerWrapper(stripe, startTime);\n    return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar stripePromise;\nvar loadCalled = false;\nvar getStripePromise = function getStripePromise() {\n    if (stripePromise) {\n        return stripePromise;\n    }\n    stripePromise = loadScript(null)[\"catch\"](function(error) {\n        // clear cache on error\n        stripePromise = null;\n        return Promise.reject(error);\n    });\n    return stripePromise;\n}; // Execute our own script injection after a tick to give users time to do their\n// own script injection.\nPromise.resolve().then(function() {\n    return getStripePromise();\n})[\"catch\"](function(error) {\n    if (!loadCalled) {\n        console.warn(error);\n    }\n});\nvar loadStripe = function loadStripe() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    loadCalled = true;\n    var startTime = Date.now(); // if previous attempts are unsuccessful, will re-load script\n    return getStripePromise().then(function(maybeStripe) {\n        return initStripe(maybeStripe, args, startTime);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBLGdCQUFnQjtBQUVwQixJQUFJQyw2QkFBNkIsU0FBU0EsMkJBQTJCQyxPQUFPO0lBQzFFLE9BQU9BLFlBQVksSUFBSSxPQUFPQTtBQUNoQztBQUVBLElBQUlDLFNBQVM7QUFDYixJQUFJQyxnQkFBZ0IsR0FBR0MsTUFBTSxDQUFDRixRQUFRLEtBQUtFLE1BQU0sQ0FBQ0wsZUFBZTtBQUNqRSxJQUFJTSxlQUFlO0FBQ25CLElBQUlDLHNCQUFzQjtBQUMxQixJQUFJQywwQkFBMEI7QUFFOUIsSUFBSUMsZ0JBQWdCLFNBQVNBLGNBQWNDLEdBQUc7SUFDNUMsT0FBT0osYUFBYUssSUFBSSxDQUFDRCxRQUFRSCxvQkFBb0JJLElBQUksQ0FBQ0Q7QUFDNUQ7QUFFQSxJQUFJRSxhQUFhLFNBQVNBO0lBQ3hCLElBQUlDLFVBQVVDLFNBQVNDLGdCQUFnQixDQUFDLGdCQUFpQlYsTUFBTSxDQUFDRixRQUFRO0lBRXhFLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJSCxRQUFRSSxNQUFNLEVBQUVELElBQUs7UUFDdkMsSUFBSUUsU0FBU0wsT0FBTyxDQUFDRyxFQUFFO1FBRXZCLElBQUksQ0FBQ1AsY0FBY1MsT0FBT0MsR0FBRyxHQUFHO1lBQzlCO1FBQ0Y7UUFFQSxPQUFPRDtJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSUUsZUFBZSxTQUFTQSxhQUFhQyxNQUFNO0lBQzdDLElBQUlDLGNBQWNELFVBQVUsQ0FBQ0EsT0FBT0Usb0JBQW9CLEdBQUcsZ0NBQWdDO0lBQzNGLElBQUlMLFNBQVNKLFNBQVNVLGFBQWEsQ0FBQztJQUNwQ04sT0FBT0MsR0FBRyxHQUFHLEdBQUdkLE1BQU0sQ0FBQ0QsZUFBZUMsTUFBTSxDQUFDaUI7SUFDN0MsSUFBSUcsYUFBYVgsU0FBU1ksSUFBSSxJQUFJWixTQUFTYSxJQUFJO0lBRS9DLElBQUks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QyxTQUFVWCxXQUFXO1FBQ2xELE9BQU9ELFdBQVdDLGFBQWFDLE1BQU16QjtJQUN2QztBQUNGO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm92ZWlnbi8uL25vZGVfbW9kdWxlcy9Ac3RyaXBlL3N0cmlwZS1qcy9kaXN0L2luZGV4Lm1qcz83NTVjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBSRUxFQVNFX1RSQUlOID0gJ2Nsb3Zlcic7XG5cbnZhciBydW50aW1lVmVyc2lvblRvVXJsVmVyc2lvbiA9IGZ1bmN0aW9uIHJ1bnRpbWVWZXJzaW9uVG9VcmxWZXJzaW9uKHZlcnNpb24pIHtcbiAgcmV0dXJuIHZlcnNpb24gPT09IDMgPyAndjMnIDogdmVyc2lvbjtcbn07XG5cbnZhciBPUklHSU4gPSAnaHR0cHM6Ly9qcy5zdHJpcGUuY29tJztcbnZhciBTVFJJUEVfSlNfVVJMID0gXCJcIi5jb25jYXQoT1JJR0lOLCBcIi9cIikuY29uY2F0KFJFTEVBU0VfVFJBSU4sIFwiL3N0cmlwZS5qc1wiKTtcbnZhciBWM19VUkxfUkVHRVggPSAvXmh0dHBzOlxcL1xcL2pzXFwuc3RyaXBlXFwuY29tXFwvdjNcXC8/KFxcPy4qKT8kLztcbnZhciBTVFJJUEVfSlNfVVJMX1JFR0VYID0gL15odHRwczpcXC9cXC9qc1xcLnN0cmlwZVxcLmNvbVxcLyh2M3xbYS16XSspXFwvc3RyaXBlXFwuanMoXFw/LiopPyQvO1xudmFyIEVYSVNUSU5HX1NDUklQVF9NRVNTQUdFID0gJ2xvYWRTdHJpcGUuc2V0TG9hZFBhcmFtZXRlcnMgd2FzIGNhbGxlZCBidXQgYW4gZXhpc3RpbmcgU3RyaXBlLmpzIHNjcmlwdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQ7IGV4aXN0aW5nIHNjcmlwdCBwYXJhbWV0ZXJzIHdpbGwgYmUgdXNlZCc7XG5cbnZhciBpc1N0cmlwZUpTVVJMID0gZnVuY3Rpb24gaXNTdHJpcGVKU1VSTCh1cmwpIHtcbiAgcmV0dXJuIFYzX1VSTF9SRUdFWC50ZXN0KHVybCkgfHwgU1RSSVBFX0pTX1VSTF9SRUdFWC50ZXN0KHVybCk7XG59O1xuXG52YXIgZmluZFNjcmlwdCA9IGZ1bmN0aW9uIGZpbmRTY3JpcHQoKSB7XG4gIHZhciBzY3JpcHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFtzcmNePVxcXCJcIi5jb25jYXQoT1JJR0lOLCBcIlxcXCJdXCIpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcblxuICAgIGlmICghaXNTdHJpcGVKU1VSTChzY3JpcHQuc3JjKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcmlwdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGluamVjdFNjcmlwdCA9IGZ1bmN0aW9uIGluamVjdFNjcmlwdChwYXJhbXMpIHtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gcGFyYW1zICYmICFwYXJhbXMuYWR2YW5jZWRGcmF1ZFNpZ25hbHMgPyAnP2FkdmFuY2VkRnJhdWRTaWduYWxzPWZhbHNlJyA6ICcnO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5zcmMgPSBcIlwiLmNvbmNhdChTVFJJUEVfSlNfVVJMKS5jb25jYXQocXVlcnlTdHJpbmcpO1xuICB2YXIgaGVhZE9yQm9keSA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keTtcblxuICBpZiAoIWhlYWRPckJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGRvY3VtZW50LmJvZHkgbm90IHRvIGJlIG51bGwuIFN0cmlwZS5qcyByZXF1aXJlcyBhIDxib2R5PiBlbGVtZW50LicpO1xuICB9XG5cbiAgaGVhZE9yQm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICByZXR1cm4gc2NyaXB0O1xufTtcblxudmFyIHJlZ2lzdGVyV3JhcHBlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyV3JhcHBlcihzdHJpcGUsIHN0YXJ0VGltZSkge1xuICBpZiAoIXN0cmlwZSB8fCAhc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcih7XG4gICAgbmFtZTogJ3N0cmlwZS1qcycsXG4gICAgdmVyc2lvbjogXCI4LjUuM1wiLFxuICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwZVByb21pc2UkMSA9IG51bGw7XG52YXIgb25FcnJvckxpc3RlbmVyID0gbnVsbDtcbnZhciBvbkxvYWRMaXN0ZW5lciA9IG51bGw7XG5cbnZhciBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihyZWplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjYXVzZSkge1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIFN0cmlwZS5qcycsIHtcbiAgICAgIGNhdXNlOiBjYXVzZVxuICAgIH0pKTtcbiAgfTtcbn07XG5cbnZhciBvbkxvYWQgPSBmdW5jdGlvbiBvbkxvYWQocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdpbmRvdy5TdHJpcGUpIHtcbiAgICAgIHJlc29sdmUod2luZG93LlN0cmlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1N0cmlwZS5qcyBub3QgYXZhaWxhYmxlJykpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBsb2FkU2NyaXB0ID0gZnVuY3Rpb24gbG9hZFNjcmlwdChwYXJhbXMpIHtcbiAgLy8gRW5zdXJlIHRoYXQgd2Ugb25seSBhdHRlbXB0IHRvIGxvYWQgU3RyaXBlLmpzIGF0IG1vc3Qgb25jZVxuICBpZiAoc3RyaXBlUHJvbWlzZSQxICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0cmlwZVByb21pc2UkMTtcbiAgfVxuXG4gIHN0cmlwZVByb21pc2UkMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUmVzb2x2ZSB0byBudWxsIHdoZW4gaW1wb3J0ZWQgc2VydmVyIHNpZGUuIFRoaXMgbWFrZXMgdGhlIG1vZHVsZVxuICAgICAgLy8gc2FmZSB0byBpbXBvcnQgaW4gYW4gaXNvbW9ycGhpYyBjb2RlIGJhc2UuXG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuU3RyaXBlICYmIHBhcmFtcykge1xuICAgICAgY29uc29sZS53YXJuKEVYSVNUSU5HX1NDUklQVF9NRVNTQUdFKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LlN0cmlwZSkge1xuICAgICAgcmVzb2x2ZSh3aW5kb3cuU3RyaXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHNjcmlwdCA9IGZpbmRTY3JpcHQoKTtcblxuICAgICAgaWYgKHNjcmlwdCAmJiBwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKEVYSVNUSU5HX1NDUklQVF9NRVNTQUdFKTtcbiAgICAgIH0gZWxzZSBpZiAoIXNjcmlwdCkge1xuICAgICAgICBzY3JpcHQgPSBpbmplY3RTY3JpcHQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NyaXB0ICYmIG9uTG9hZExpc3RlbmVyICE9PSBudWxsICYmIG9uRXJyb3JMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3NjcmlwdCRwYXJlbnROb2RlO1xuXG4gICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgc2NyaXB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWRMaXN0ZW5lcik7XG4gICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3JMaXN0ZW5lcik7IC8vIGlmIHNjcmlwdCBleGlzdHMsIGJ1dCB3ZSBhcmUgcmVsb2FkaW5nIGR1ZSB0byBhbiBlcnJvcixcbiAgICAgICAgLy8gcmVsb2FkIHNjcmlwdCB0byB0cmlnZ2VyICdsb2FkJyBldmVudFxuXG4gICAgICAgIChfc2NyaXB0JHBhcmVudE5vZGUgPSBzY3JpcHQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX3NjcmlwdCRwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NyaXB0JHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgc2NyaXB0ID0gaW5qZWN0U2NyaXB0KHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIG9uTG9hZExpc3RlbmVyID0gb25Mb2FkKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICBvbkVycm9yTGlzdGVuZXIgPSBvbkVycm9yKHJlamVjdCk7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZExpc3RlbmVyKTtcbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3JMaXN0ZW5lcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KTsgLy8gUmVzZXRzIHN0cmlwZVByb21pc2Ugb24gZXJyb3JcblxuICByZXR1cm4gc3RyaXBlUHJvbWlzZSQxW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgc3RyaXBlUHJvbWlzZSQxID0gbnVsbDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9KTtcbn07XG52YXIgaW5pdFN0cmlwZSA9IGZ1bmN0aW9uIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSkge1xuICBpZiAobWF5YmVTdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwayA9IGFyZ3NbMF07XG4gIHZhciBpc1Rlc3RLZXkgPSBway5tYXRjaCgvXnBrX3Rlc3QvKTsgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIG5vdCBwdWJsaWNseSB0eXBlZFxuXG4gIHZhciB2ZXJzaW9uID0gcnVudGltZVZlcnNpb25Ub1VybFZlcnNpb24obWF5YmVTdHJpcGUudmVyc2lvbik7XG4gIHZhciBleHBlY3RlZFZlcnNpb24gPSBSRUxFQVNFX1RSQUlOO1xuXG4gIGlmIChpc1Rlc3RLZXkgJiYgdmVyc2lvbiAhPT0gZXhwZWN0ZWRWZXJzaW9uKSB7XG4gICAgY29uc29sZS53YXJuKFwiU3RyaXBlLmpzQFwiLmNvbmNhdCh2ZXJzaW9uLCBcIiB3YXMgbG9hZGVkIG9uIHRoZSBwYWdlLCBidXQgQHN0cmlwZS9zdHJpcGUtanNAXCIpLmNvbmNhdChcIjguNS4zXCIsIFwiIGV4cGVjdGVkIFN0cmlwZS5qc0BcIikuY29uY2F0KGV4cGVjdGVkVmVyc2lvbiwgXCIuIFRoaXMgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vZG9jcy5zdHJpcGUuY29tL3Nka3Mvc3RyaXBlanMtdmVyc2lvbmluZ1wiKSk7XG4gIH1cblxuICB2YXIgc3RyaXBlID0gbWF5YmVTdHJpcGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgcmVnaXN0ZXJXcmFwcGVyKHN0cmlwZSwgc3RhcnRUaW1lKTtcbiAgcmV0dXJuIHN0cmlwZTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5cbnZhciBzdHJpcGVQcm9taXNlO1xudmFyIGxvYWRDYWxsZWQgPSBmYWxzZTtcblxudmFyIGdldFN0cmlwZVByb21pc2UgPSBmdW5jdGlvbiBnZXRTdHJpcGVQcm9taXNlKCkge1xuICBpZiAoc3RyaXBlUHJvbWlzZSkge1xuICAgIHJldHVybiBzdHJpcGVQcm9taXNlO1xuICB9XG5cbiAgc3RyaXBlUHJvbWlzZSA9IGxvYWRTY3JpcHQobnVsbClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAvLyBjbGVhciBjYWNoZSBvbiBlcnJvclxuICAgIHN0cmlwZVByb21pc2UgPSBudWxsO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH0pO1xuICByZXR1cm4gc3RyaXBlUHJvbWlzZTtcbn07IC8vIEV4ZWN1dGUgb3VyIG93biBzY3JpcHQgaW5qZWN0aW9uIGFmdGVyIGEgdGljayB0byBnaXZlIHVzZXJzIHRpbWUgdG8gZG8gdGhlaXJcbi8vIG93biBzY3JpcHQgaW5qZWN0aW9uLlxuXG5cblByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZ2V0U3RyaXBlUHJvbWlzZSgpO1xufSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgaWYgKCFsb2FkQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgfVxufSk7XG52YXIgbG9hZFN0cmlwZSA9IGZ1bmN0aW9uIGxvYWRTdHJpcGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2FkQ2FsbGVkID0gdHJ1ZTtcbiAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7IC8vIGlmIHByZXZpb3VzIGF0dGVtcHRzIGFyZSB1bnN1Y2Nlc3NmdWwsIHdpbGwgcmUtbG9hZCBzY3JpcHRcblxuICByZXR1cm4gZ2V0U3RyaXBlUHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24gKG1heWJlU3RyaXBlKSB7XG4gICAgcmV0dXJuIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IHsgbG9hZFN0cmlwZSB9O1xuIl0sIm5hbWVzIjpbIlJFTEVBU0VfVFJBSU4iLCJydW50aW1lVmVyc2lvblRvVXJsVmVyc2lvbiIsInZlcnNpb24iLCJPUklHSU4iLCJTVFJJUEVfSlNfVVJMIiwiY29uY2F0IiwiVjNfVVJMX1JFR0VYIiwiU1RSSVBFX0pTX1VSTF9SRUdFWCIsIkVYSVNUSU5HX1NDUklQVF9NRVNTQUdFIiwiaXNTdHJpcGVKU1VSTCIsInVybCIsInRlc3QiLCJmaW5kU2NyaXB0Iiwic2NyaXB0cyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImkiLCJsZW5ndGgiLCJzY3JpcHQiLCJzcmMiLCJpbmplY3RTY3JpcHQiLCJwYXJhbXMiLCJxdWVyeVN0cmluZyIsImFkdmFuY2VkRnJhdWRTaWduYWxzIiwiY3JlYXRlRWxlbWVudCIsImhlYWRPckJvZHkiLCJoZWFkIiwiYm9keSIsIkVycm9yIiwiYXBwZW5kQ2hpbGQiLCJyZWdpc3RlcldyYXBwZXIiLCJzdHJpcGUiLCJzdGFydFRpbWUiLCJfcmVnaXN0ZXJXcmFwcGVyIiwibmFtZSIsInN0cmlwZVByb21pc2UkMSIsIm9uRXJyb3JMaXN0ZW5lciIsIm9uTG9hZExpc3RlbmVyIiwib25FcnJvciIsInJlamVjdCIsImNhdXNlIiwib25Mb2FkIiwicmVzb2x2ZSIsIndpbmRvdyIsIlN0cmlwZSIsImxvYWRTY3JpcHQiLCJQcm9taXNlIiwiY29uc29sZSIsIndhcm4iLCJfc2NyaXB0JHBhcmVudE5vZGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVycm9yIiwiaW5pdFN0cmlwZSIsIm1heWJlU3RyaXBlIiwiYXJncyIsInBrIiwiaXNUZXN0S2V5IiwibWF0Y2giLCJleHBlY3RlZFZlcnNpb24iLCJhcHBseSIsInVuZGVmaW5lZCIsInN0cmlwZVByb21pc2UiLCJsb2FkQ2FsbGVkIiwiZ2V0U3RyaXBlUHJvbWlzZSIsInRoZW4iLCJsb2FkU3RyaXBlIiwiX2xlbiIsImFyZ3VtZW50cyIsIkFycmF5IiwiX2tleSIsIkRhdGUiLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/lib/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadStripe: () => (/* reexport safe */ _dist_index_mjs__WEBPACK_IMPORTED_MODULE_0__.loadStripe)\n/* harmony export */ });\n/* harmony import */ var _dist_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/index.mjs */ \"(ssr)/./node_modules/@stripe/stripe-js/dist/index.mjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JvdmVpZ24vLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvbGliL2luZGV4Lm1qcz84YTY3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL2Rpc3QvaW5kZXgubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/lib/index.mjs\n");

/***/ })

};
;